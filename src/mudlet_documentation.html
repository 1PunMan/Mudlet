<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.4.1" />
<title>Mudlet Manual</title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
</style>
</head>
<body>
<div id="header">
<h1>Mudlet Manual</h1>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">Table of Contents</div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<a href="#introduction">General Introduction to Modern MUD Clients.</a>
</p>
</li>
<li>
<p>
<a href="#manual">Technical Manual</a>
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
<a href="#splitScreen">Split Screen</a>
</p>
</li>
<li>
<p>
<a href="#commandLine">Mudlet&#8217;s Command Line</a>
</p>
</li>
<li>
<p>
<a href="#logging">Logging to HTML log files</a>
</p>
</li>
<li>
<p>
<a href="#export">Import &amp; Export of Packages</a>
</p>
</li>
<li>
<p>
<a href="#alias">The Alias Engine</a>
</p>
</li>
<li>
<p>
<a href="#triggers">The Trigger Engine</a>
</p>
</li>
<li>
<p>
<a href="#timers">The Timer Engine</a>
</p>
</li>
<li>
<p>
<a href="#keys">Key Bindings</a>
</p>
</li>
<li>
<p>
<a href="#buttons">Buttons and Menus</a>
</p>
</li>
</ol></div>
</li>
<li>
<p>
<a href="#scripting">Scripting</a>
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
<a href="#luaSyntax">Introduction to Scripting with Mudlet</a>
</p>
</li>
<li>
<p>
<a href="#luaTables">Lua Tables and Dictionaries</a>
</p>
<div class="olist lowerroman"><ol class="lowerroman">
<li>
<p>
<a href="#matches">Single Line Trigger Scripts</a>
</p>
</li>
<li>
<p>
<a href="#multimatches">Multiline Trigger Scripts</a>
</p>
</li>
</ol></div>
</li>
<li>
<p>
<a href="#events">Events - Defining &amp; Using Event Handlers</a>
</p>
</li>
<li>
<p>
<a href="#cursorControl">Cursor Control - Custom Printing</a>
</p>
</li>
<li>
<p>
<a href="#lineTriggers">Using tempLineTrigger</a>
</p>
</li>
</ol></div>
</li>
<li>
<p>
<a href="#exampleScripts">Advanced Learning From Selected Example Scripts</a>
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
<a href="#inlineMapExample">inlineMapExample</a>
</p>
</li>
<li>
<p>
<a href="#silbermine">Auto Miner Bot Example - How to write a little Bot with Mudlet?</a>
</p>
</li>
</ol></div>
</li>
<li>
<p>
<a href="#customGui">Custom GUI Elements</a>
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
<a href="#userWindows">User Terminal Windows</a>
</p>
</li>
<li>
<p>
<a href="#userWebkitWindows">User Webkit Webbrowser Windows</a>
</p>
</li>
<li>
<p>
<a href="#labels">Custom Mini Text Displays - Scripting Labels</a>
</p>
</li>
<li>
<p>
<a href="#buttons">Scripting Buttons</a>
</p>
</li>
<li>
<p>
<a href="#userGfxWindows">User Custom Graphics Windows</a>
</p>
</li>
</ol></div>
</li>
<li>
<p>
<a href="#api">Lua API and Reference</a>
</p>
</li>
</ol></div>
</div></div>
</div>
</div>
<h2 id="introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Welcome to <strong>Mudlet</strong>, a modern MUD client for GNU/Linux that offers all the tools to get the most out of your gaming experience.
Throughout this document we hope to familiarize you with the basic aspects of Mudlet, from the interface to its <em>very</em> powerful and feature rich scripting backend.
The main focus in the development of Mudlet has been efficiency and performance, but we also try to make it as easily accessible
as possible. However, keep in mind that this is a complex piece of software with a large set of tools that do require some understanding of the underlying principle.
To use Mudlet in any meaningful way, you have to take a closer look at the technical section in this manual. If you are not familiar with using modern MUD clients in general you should also take a look
at the general introduction to MUD clients section in this manual.
You are welcome to ask questions on the forum of our website. If you find a bug, please let us know.</p></div>
<h3 id="_quick_start">Quick Start</h3>
<div class="paragraph"><p>To connect to the MUD of your choice, click on <tt>Connections</tt> → <tt>Connection Profiles</tt>.</p></div>
<div class="ulist"><ul>
<li>
<p>
Create a new profile by clicking on <tt>Add New Profile</tt>.
</p>
</li>
<li>
<p>
Specify the <tt>host</tt> and the <tt>port</tt> of the MUD (This information is usually found on the MUD&#8217;s homepage).
</p>
</li>
<li>
<p>
Now just click <tt>Connect</tt> to play!
</p>
</li>
</ul></div>
</div>
<h2 id="introduction">1. General Introduction to Modern MUD Clients</h2>
<div class="sectionbody">
<h3 id="_1_1_mudlet_8217_s_automation_features">1.1 Mudlet&#8217;s automation features</h3>
<div class="paragraph"><p>Mudlet offers a vast array of standard features to automate or otherwise improve your gaming experience. These include, but are not limited to:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Aliases</strong> – user-defined text input, which is converted into a different, usually longer input before being sent to the MUD, e.g. <tt>gg</tt> → <tt>get gold from ground;put gold in 2.bag</tt>.
</p>
</li>
<li>
<p>
<strong>Keybindings</strong> – also known as hotkeys, allow executing certain user-defined commands by simultaneously pressing a specific combination of keys, e.g. <tt>CTRL+H</tt> → <tt>send say Hello Miyuki!</tt> to the MUD or <tt>plays La Marseillaise</tt>
</p>
</li>
<li>
<p>
<strong>Triggers</strong> – execute user-defined commands upon receiving specific out from the MUD, e.g. MUD sends <tt>You see Elyssa standing here.</tt> → send <tt>poke Elyssa</tt> to the MUD.
</p>
</li>
<li>
<p>
<strong>Timers</strong> – delay the execution of a command or execute it after a specified period of time, e.g. <tt>throw gauntlet to Eric</tt>-<tt>wait 3 seconds</tt>-<tt>exclaim Let us end this here!</tt>
</p>
</li>
<li>
<p>
<strong>Variables</strong> – allow the user to store text or numbers for easier use inside scripts.
</p>
</li>
<li>
<p>
<strong>Events</strong> – allow the user to make triggers for specific events like when Mudlet has connected to the MUD, or even user-defined events to use in complex system making.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Scripting allows the user to create automation utilities (triggers, aliases) with the Lua scripting language. The possibilities of what can be achieved by using this technique are, practically speaking, endless - ranging from teaching the client how to heal your character in combat for you to creating a fully automated robot (known as `bot`s) that will completely take over the control for your character (especially useful for completing repetitive, rudimentary tasks).</p></div>
<h3 id="_1_2_automation_and_mud_rules">1.2 Automation and MUD rules</h3>
<div class="paragraph"><p>Effectively speaking, it is possible to create an AI (Artificial Intelligence) that does everything you can do in a MUD. Even more so, the program will be able outperform you in almost every routine operation. The difficulty of creating such a program depends on the task it has to perform: gathering loot being very easy, walking through a dungeon and leveling you character being moderately easy and socially interacting with other real people being outrageously difficult (see <a href="http://alice.pandorabots.com/">A.L.I.C.E.</a>). In the end of the day, you&#8217;re teaching your client to process information and act the way you consider best suited.
Because scripting is so powerful, it can give you a competitive advantage that some people consider it unfair or even cheating. As of the moment of this writing (2 November 2008), this sort of automation can be best observed in commercial massively-multiplayer online role-playing games (MMORPG), known as gold-farming or power-leveling. The basic idea is creating a system that will raise your character to the maximum level and gather in-game currency in the process, both of which can be effectively exchanged for real-world currency. The spread of the above aspects can have much more far reaching consequences than just being unfair, such as inflation, loss of balance in terms of game-mechanics or, ultimately, a complete crash of in-game economy. For more information see the paper <a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1235602">"Simple Economics of Real-Money Trading in Online Games"</a> by Jun-Sok Huhh of the Seoul National University.
For these, and various other, reasons the administrators and owners of the corresponding virtual worlds can forbid the usage of automation tools. A failure to comply can result in suspension or deletion of the user&#8217;s character or account for future denial of service.
By including scripting support in Mudlet, we effectively give you the ability to create and utilise AI tool-kits, however, we do not endorse or promote the usage of these systems if it&#8217;s prohibited in your MUD. Keep in mind that by cheating you can lessen the quality of gameplay for both, your fellow players and yourself.</p></div>
<h3 id="_1_3_basic_scripting">1.3 Basic scripting</h3>
<div class="paragraph"><p>The following part of the guide is written for new beginners in scripting. If you&#8217;re coming over from zMud or cMud, you may move on to section two.</p></div>
<h4 id="_1_4_variables_basics">1.4 Variables - basics</h4>
<div class="paragraph"><p>Variables are containers for data. In Lua, they can store numbers or words. You can use variables to store important information like how much gold do you have, or have them remember things for you.</p></div>
<div class="paragraph"><p>The syntax for making a variable remember a number is the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>variable = number</tt></pre>
</div></div>
<div class="paragraph"><p>Or to make it remember some text:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>variable = "some text"</tt></pre>
</div></div>
<div class="paragraph"><p>For example, here we&#8217;ll set the <tt>myhealth</tt> variable to number <tt>1345</tt>, and the <tt>myname</tt> variable to <tt>Anna</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>myhealth = 1345
myname = "Anna"</tt></pre>
</div></div>
<div class="paragraph"><p>You can also do basic maths easily, for example:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>a = 2 + 2 --sets variable a to the value of 4
b = a - 1 --sets variable b to the value of 3</tt></pre>
</div></div>
<div class="paragraph"><p>To concatenate strings together, you can use the <tt>..</tt> expression:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>first_name = "Joe"
last_name = "Plumber"
full_name = firstname .. " " .. last_name --sets the full_name variable to "Joe Plumber", with a space inbetween.</tt></pre>
</div></div>
<h4 id="_1_5_how_to_send_text_to_the_mud">1.5 How to send text to the mud</h4>
<div class="paragraph"><p>To send a command to the MUD, you can use the <tt>send()</tt> function. Data inside the quotes is sent to the MUD.</p></div>
<div class="paragraph"><p>For example, the following code sends the command to <tt>eat bread</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send("eat bread")</tt></pre>
</div></div>
<div class="paragraph"><p>If you&#8217;d like to include variables in the send command, you need to prefix and suffix them with two dots outside the quotes, like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send("My name is " .. full_name .. ". What's yours?")</tt></pre>
</div></div>
<h4 id="_1_6_how_to_echo_text_to_yourself">1.6 How to echo text to yourself</h4>
<div class="paragraph"><p>To echo (show text to yourself) you can use the <tt>echo()</tt> or the <tt>insertText()</tt> function.
For example, the following code will display <tt>Time to eat dinner!</tt> on your screen:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>echo("Time to eat dinner")</tt></pre>
</div></div>
<div class="paragraph"><p>If you&#8217;d like to include variables in your echo, you concatenate the value of your variable to the text:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>my_old = 5;
echo("I have " .. my_gold .. " pieces of gold!");</tt></pre>
</div></div>
<h4 id="_1_7_aliases">1.7 Aliases</h4>
<div class="paragraph"><p>The aliases are the most basic way of automating the gameplay - you can use aliases to shorten the amount of typing you do. For example:</p></div>
<div class="quoteblock">
<div class="title">Example - Brew&#8217;o'Matic 6000</div>
<div class="content">
<div class="paragraph"><p>You&#8217;re walking around the epic dungeon of the Unholy Firedragon of Westersand, gathering roots in order to brew a potion and thus restore the growth of hair on Farmer Benedict&#8217;s bald head. Once you see a root, you need to:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>open the bag of tools
get the sickle of damnation from the bag of tools
cut the root of hair-growth
clean the sickle of damnation of deadly root acid
put the sickle of damnation in the bag of tools
close the bag of tools
open the magical bag of storing
take the root
put the root into the magical bag of storing
close the magical of storing</tt></pre>
</div></div>
<div class="paragraph"><p>and once you&#8217;re done, do the exact same thing nine more times&#8230; trice a day.</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Alternatively, you just create an alias that would do this all with a single command - for example, <tt>quest</tt>.</p></div>
<h5 id="_1_8_making_a_simple_alias">1.8 Making a simple alias</h5>
<div class="paragraph"><p>To get started, go click on the <tt>Aliases</tt> button in Mudlet, and then on the <tt>Add</tt> one. This will make a blank alias for you, which we&#8217;ll now fill in.</p></div>
<div class="paragraph"><p>The <tt>Alias name</tt> field is optional - it&#8217;s mainly used for the alias listing that you see on the left as an easy way to distintuish all of the aliases.
You can just name our alias <tt>test</tt> for now.
The <tt>Regex</tt> field is where you&#8217;d put in the alias command, i. e. the command that is being sent to the MUD instead of the alias. In other words, the alias is a front for a real command. We call this substitution process alias expansion.
Mudlet uses Perl regular expression aliases. Regexes are a special way of matching patterns of words. For the beginners it is enough to think of them as a general way to specify the words itself and their placement within the line.
For basic alias it is enough to know that the character ^ symbolizes the beginning of the line and the charachter $ symbolizes the end of the line.
If you want to make an alias "tw" that sends the command "take weapon", you don&#8217;t have to care about placement or pattern matching in general.
All you need to do is fill "tw" in the field called "Regex" and type "take weapon" in the field called "substitution". Then you need to save the new alias by clicking on the "Save" icon in the top middle.
The symbol for unsaved items disappears and makes way for a little blue checkbox. If this box is checked the alias is active. If the blue box is empty, the alias is deactived and will not work unless you press the "activate" toggle padlock icon.
Now you are ready to go. Type "tw" in the command line and press the enter key. Mudlet will send "take weapon" to the MUD.
Alias as basically, a feature to save you a bit of typing - much like buttons which will be described in detail in section two of the manual.
To learn more about more complex aliases have a look at section 2 of the manual.</p></div>
<h4 id="_1_9_simple_triggers">1.9 Simple Triggers</h4>
<div class="paragraph"><p>Triggers are an automation feature offered in many modern MUD clients. They allow you quicker response to a parcticular situation or greater convenience since you need to do less manual work.
The way a trigger works is simple: You define some text that you want to trigger some action. When the trigger sees this text in the MUD output, it&#8217;ll run the commands you&#8217;ve told it to.
Example: Whenever you see a bunny you want to attack it. You type "bunny" in the field titled "Add to List" and then either press the enter key or click on the little + icon next to the input line to add this word to the list of texts this trigger fires on.
Now you type "kill bunny" in the field called command. Then click on the save icon to save the trigger and make sure the trigger is actually active (= blue checkbox icon is checked). When the trigger is active each time the word "bunny" will appear in the MUD output, your trigger will issue the command "kill bunny".
If you want to stop hunting bunnies, you can simply select the bunny trigger and then click on the padlock icon to deactivate the trigger.
The trigger will stop to fire until you re-enable it again via the padlock icon.</p></div>
<h5 id="_1_10_matching_one_unknown">1.10 Matching one unknown</h5>
<div class="paragraph"><p>You can also set up a trigger to gather the scimitars, gold or whatever the skeletons could carry around with them. Since we do not know what the loot is, we will need to set up a trigger to match the line and take whatever was dropped. Examples:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>The skeleton drops ring.
The skeleton drops gold.
The skeleton drops scimitar.</tt></pre>
</div></div>
<div class="paragraph"><p><tt>The skeleton drops_</tt> is the generic segment of the line, the loot itself varies. Thus, we need to tell the client to <tt>take_</tt> whatever the skeleton dropped. We do this by setting up a so-called <tt>regular expression</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: The skeleton drops (.*?)\.
Script: send("take " .. matches[2]);</tt></pre>
</div></div>
<div class="paragraph"><p>The expression <tt>(.*?)</tt> matches any characters that the client receives between <tt>The skeleton drops_</tt> (NB: notice the blank at the end) and the full-stop.
<tt>matches[2]</tt> simply transfers <em>the first matched text fitting the search criterea</em> into the output (matches[1] contains the entire matched text, matches[2] contains the first capture group. More on this in section two of the manual).</p></div>
<h5 id="_1_11_matching_multiple_unknowns">1.11 Matching multiple unknowns</h5>
<div class="paragraph"><p>Now, let&#8217;s try making a trigger that would gather the loot from anybody:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: (.*?) drops (.*?).
Script:
send("take " .. matches[3])</tt></pre>
</div></div>
<div class="paragraph"><p>In this case, any time somebody, or something, drops something else, or someone else, the client will pick it up. Note that we used <tt>matches[3]</tt> instead of <tt>matches[2]</tt> this time, in order to pick up the second match. If we used <tt>matches[2]</tt>, we&#8217;d end up picking up the skeleton&#8217;s corpse.</p></div>
<h5 id="_1_12_matching_known_variants">1.12 Matching known variants</h5>
<div class="paragraph"><p>If you&#8217;re playing a MUD in English, you&#8217;ll notice that these triggers probably won&#8217;t work due to English syntax. Compare:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>The skeleton drops apple.
The skeleton drops an apple.</tt></pre>
</div></div>
<div class="paragraph"><p>Chances are that you&#8217;ll see the later a little more often. If we used our old RegEx, the output would look something like this.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>INPUT: The skeleton drops an apple.
OUTPUT: take an apple</tt></pre>
</div></div>
<div class="paragraph"><p>Most MUDs can&#8217;t handle determiners, such as articles (i.e. <tt>a</tt>, <tt>an</tt>, <tt>the</tt>) or quantifiers (e.g. <tt>five</tt>, <tt>some</tt>, <tt>each</tt>), in user-input. To match this line we could either create multiple triggers matching every possible article or a regular expression filtering out these words:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: (.*?) drops (a|an|the|some|a couple of|a few|) (.*?).
Script:
send("take " .. matches[4])</tt></pre>
</div></div>
<div class="paragraph"><p>Once again, note that we&#8217;re using the third match (<tt>matches[4]</tt>) this time.
NOTE: Certain other languages, with a morphology richer than that of English, might require a somewhat different approach. If you&#8217;re stuck, and your MUD-adminitrators don&#8217;t prohibit the use of triggers, try asking on the corresponding world&#8217;s forums.</p></div>
<div class="paragraph"><p>For more information, see the chapter Regular Expressions.</p></div>
<h4 id="_1_13_explain_basic_regex_characters_w_d_and_and_how_to_use_them_properly">1.13 explain basic regex characters (^, $, (\w+), (\d+) and .*) and how to use them properly.</h4>
<h4 id="_retrieving_wildcards_from_triggers">Retrieving wildcards from triggers</h4>
<div class="paragraph"><p>Wildcards from triggers are stored in the <em>matches[]</em> table. The first wildcard goes into <em>matches[1]</em>, second into <em>matches[2]</em>, and so on, for however many wildcards do you have in your trigger.</p></div>
<div class="paragraph"><p>For example, you&#8217;d like to say outloud how much gold did you pick up from a slain monster. The message that you get when you pick up the gold is the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>You pick up 16 gold.</tt></pre>
</div></div>
<div class="paragraph"><p>A trigger that matches this pattern could be the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: You pick up (\d+) gold</tt></pre>
</div></div>
<div class="paragraph"><p>And in your code, the variables <tt>matches[2]</tt> will contain the amount of gold you picked up (in this case, <em>16</em>). So now to say outloud how much gold did you loot, you can do the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Script: echo("I got " .. matches[2] " gold!")</tt></pre>
</div></div>
<h5 id="_more_advanced_example">More advanced example</h5>
<div class="paragraph"><p>Here&#8217;s an example by Heiko, which makes you talk like Yoda:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: say (\w+).*(\w*).*(.*)
Script:  command = "say "..matches[4].." "..matches[2].." "..matches[3]</tt></pre>
</div></div>
<div class="paragraph"><p>What it does here is save the <tt>first word</tt>, the <tt>second word</tt> and then the <tt>rest of the text</tt> into wildcards. It then says <tt>rest of the text</tt> first, then the <tt>first word</tt> and then the <tt>second word</tt>.</p></div>
<h4 id="_1_14_how_to_highlight_words">1.14 How to highlight words</h4>
<div class="paragraph"><p>To highlight something in Mudlet, you first use the <tt>selectString()</tt> function to select what you&#8217;d like to highlight, and then either the <tt>fg</tt> function to color the letters or <tt>bg</tt> to highlight the background of the letters. For example, the following code would highlight the word <tt>pond</tt> in a bluebackground and red letters:
The first parameter to selectString() is the text you want to select and the second parameter tells the function which occurence of the word in the current line you want to select i.e. the first, the second, the third etc.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString( "pond", 1 )
fg( "red " )
bg( "blue" )</tt></pre>
</div></div>
<h4 id="_1_15_keybindings">1.15 Keybindings</h4>
<div class="paragraph"><p>Keybindings, or hotkeys, are in many respects very similar to aliases, however, instead of typing in what you want to be done, you simply hit a key (or combination of keys) and let the Mudlet do the work.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Example - You don&#8217;t drink tea, you sip it!</div>
<div class="paragraph"><p>You&#8217;re participating in an in-game tea sipping contest. The winner is the first person to sip an Earl Grey, should the quiz-master make a vague reference to a series of tubes, or a Ceylon Mint, if he begins talking about the specific theory of relativity. In order to give us a competitive advantage, we will define two keybindings:</p></div>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>HOTKEY: F1
EXPAND TO: sip earl grey

HOTKEY: F2
EXPAND TO: sip ceylon mint</tt></pre>
</div></div>
<div class="paragraph"><p>Now you just have to listen, or rather read, carefully and hit either F1 or F2 to claim that prize.</p></div>
<div class="paragraph"><p>Another practical use for keybindings would be creating a so-called "targeting system", which is especially useful for grinding down armies of pumpkin-men in MUDs without auto-attack. See the Variables chapter for further details.</p></div>
<h4 id="_1_16_timers">1.16 Timers</h4>
<div class="paragraph"><p>Timers, as the name suggests, can be used to execute a specific command at a certain time, after a certain time or once every so often.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Example - Don&#8217;t miss the training!</div>
<div class="paragraph"><p>Your character can train in his attributes once every three hours. You could either try tracking this manually or add a trigger starting timer after each training. Once the three hours have passed, your character will conveniently say to himself that it is time to do a couple of push-ups.</p></div>
</div></div>
</div>
<h2 id="manual">Main Manual</h2>
<div class="sectionbody">
</div>
<h2 id="_multi_session_gameing">Multi Session Gameing</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet lets you play several simultaneous MUD sessions. However, currently we have the restriction that you cannot use the same profile twice. Consequently, if you want to play three characters on the same MUD at the same time, you need to make 3 profiles with 3 different names e.g. <a href="mailto:ernie@avalon.de">ernie@avalon.de</a>, <a href="mailto:bert@avalon.de">bert@avalon.de</a> etc.</p></div>
</div>
<h2 id="splitScreen">Split Screen</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet has a <em>split screen</em>. If you scroll up in the old text, the screen will split in two parts. The lower part will follow the MUD output while the upper part will stay focused on your scrolling. This way you can read easier through old passages without missing what is going on at the moment.</p></div>
<div class="paragraph"><p>Split screen can be activated via the page up / page down keys or with the mouse wheel. Scrolling back to the end will close the split screen automatically. A click on the middle mouse button will close the split screen immediately as well as pressing control+return on the keyboard. The size of the 2 parts of the split screen can be modidfied when dragging the seperator bar with the mouse.
Split screen usage is necessary when selecting text in order to copy it to trigger editor e.g. when making triggers. If you don&#8217;t use split screen when selecting text, new arriving text will upset your selection.</p></div>
</div>
<h2 id="commandLine">Command Line Auto-Completion, Tab-Completion and History</h2>
<div class="sectionbody">
<div class="paragraph"><p>The command line offers Tab Completion (TAB key) and Autocompletion (cursor up key).
1. <em>Tab completion</em> searches the MUD output buffer for words matching the word that you are currently typing. This is useful if you have to type complicated long names. You only have to type the first letters and then press the tab key until the proposal is what you want.
2. <em>Autocompletion</em> tries to match your current typing with your command history. Example: If you typed the same command a while ago, you only have to start typing the first couple of letters and then press the cursor up key until the proposal matches the command that you want to use.
3. <em>Command History</em>: If you haven&#8217;t started to type anything yet, you can browse through your command history with the cursur up and cursor down keys. However, if you have started typing pressing cursor up will result in autocompletion.
4. <em>ESC</em>:To get out of autocompletion you can press the ESC key any time.</p></div>
</div>
<h2 id="logging">Logging Output to HTML Log Files</h2>
<div class="sectionbody">
<div class="paragraph"><p>Press on the little button with the blue folder with the green arrow icon on the lower right side of the screen next to the command line.</p></div>
<div class="paragraph"><p>Clicking it a second time stops logging. A red system message will tell you where you can find the log file. Just copy the the filename and open the log file in your web browser. The log files are html files that can be put on web pages without any further editing etc..
Log files can be found at the mudlet home directory in your profile directory. The path is &lt;path to mudlet home&gt;/.config/mudlet/profiles/&lt;name&gt;/logs On Linux this would be: /home/username/.config/mudlet/profiles/profilename/logs</p></div>
<div class="paragraph"><p>On Windows the path prefix depends on your windows version and your language settings: On my system it&#8217;s c:\Dokumente und Einstellungen\heiko\.config\mudlet\profiles\&lt;name&gt;\logs. Log files have a file name similar to the autosaved profiles: date#time.html</p></div>
</div>
<h2 id="export">Exporting and Importing Profiles or Packages</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet supports XML packages that can be imported and exported while playing. You can find a package section on the forum of <a href="http://mudlet.sourceforge.net">http://mudlet.sourceforge.net</a> where you can download ready made packages for your MUD or upload your own packages for other players to use. A package can contain anything ranging from a single trigger to hundrets of button groups, trigger groups alias - in other words, entire "systems". To import a package you simply have to open the trigger editor and click the import icon, select the xml package file and import it. Often package files will be compressed to save space. If the file is compressed, you&#8217;ll need to uncompress it before importing it.</p></div>
<h3 id="_importing_packages">Importing Packages</h3>
<div class="paragraph"><p>The imported package will be stored permanently in your profile when you safe the profile. If you don&#8217;t like the imported package, delete its components manually or simply don&#8217;t save the profile. Then the new content will be lost on restart. Automatic package removal is not yet supported in Mudlet.</p></div>
<div class="paragraph"><p>Packages are nothing else, but profiles - or parts of profiles that can be exchanged, imported and exported between your own profiles and between different players. From a technical perspective a package and a profile xml file are the same thing.</p></div>
<h3 id="_sharing_your_scripts_exporting_items_or_profiles">Sharing your scripts - Exporting items or profiles</h3>
<div class="paragraph"><p>Mudlet stores your profiles as XML files in your home directory under .config/mudlet/profiles/your_profile_name/current (note the leading dot).</p></div>
<div class="paragraph"><p>The file name consists of the date and time, the profile was written to disc.
You can export packages of a trigger branch, alias branch, function key, scripts etc. by clicking on a folder in the tree of the particular item in question and then click on the export icon. You&#8217;ll be asked to give a filename for your package. You can export arbitrarily complex structures by moving them into a folder. You cannot mix items at the moment. Importing packages is straight forward and fully automatic.
You can also import entire profiles as they are basically packages.</p></div>
</div>
<h2 id="alias">Mudlet&#8217;s Alias Engine</h2>
<div class="sectionbody">
<div class="paragraph"><p>Alias are triggers that operate on user input. Mudlet uses hierarchically ordered powerful Perl regex expression alias.
We have explicitly chosen not to offer multi condition alias or the same trigger types the trigger engine offers because this would be way over the top and is simply not needed for alias expansion - although it should be noted that the processes are closely related, except that alias, i.e. input triggers operates on a different data stream, namely the user input stream, whereas triggers operate on the MUD output data stream.
We are talking a bit about what is going on behind the scenes, in order to make clear that alias and triggers are essentially the same thing. In Mudlet triggers and alias are treated the same way, work the same way and only differ in terms of complexity and the amount of features.</p></div>
<div class="paragraph"><p>Now, how does it all work? When you enter a command on the keyboard and press enter or return, the text that you have typed in the command line will be forwarded to the alias unit, i. e. the input trigger unit. The text will be matched against all active alias in the hierarchy unless access to a branch is locked by the user or by a script.
For an input trigger to match the command text the same rules as explained above in the trigger section apply. However, to simplify matters there is only one alias type. As alias are not performance critical we could reduce the amount of trigger types to just Perl regex as this type can do it all and performance is no issue with alias as the amount of data is much less. Even if you type like a madman you&#8217;ll never get close to sending the same amount of text to the MUD than the amount of text the MUD sends back to you.</p></div>
<div class="paragraph"><p>What does it mean that a regex is true or "matched"? A trigger or an alias fires - or executes its commands/script - when the text matches the pattern of the trigger or alias. In most cases this means that the text contains the trigger/alias pattern. If the regex pattern is <tt style="color: blue;background-color: #b0e0e6;">reen</tt> then a text "The green house" will match because "reen" is contained in the text. More complex regex patterns can also hold information on where in the text a certain pattern must occur in order to match. <tt style="color: blue;background-color: #b0e0e6;">^tj</tt> only matches when the letters "tj" occur at the beginning of the text. Consequently, a text like "go tj" would not match.
Regex patterns can also capture data like numbers, sequences of letters, words etc. at certain positions in the text. This is very useful for MUD related scripting and this is why it is explained below.</p></div>
<div class="paragraph"><p>Let&#8217;s get back to alias. We start with a simple example.</p></div>
<div class="paragraph"><p>We want Mudlet to send "put weapon in bag" whenever we type "pwb". Consequently, the pattern is <tt style="background-color: #b0e0e6;">pwb</tt> and as the task is so simple it&#8217;s enough to enter "put weapon in bag" in the send field. Then we click on save to save the changes and activate the alias by clicking on the padlock icon.
Then we leave the trigger editor and test our new alias. After typing "pwb" and pressing return Mudlet will send the command "put weapon in bag" to the MUD.</p></div>
<div class="paragraph"><p>Let&#8217;s move on to a more complicated example that is needed very often.</p></div>
<div class="paragraph"><p>We want our script to automatically put the weapon in the correct bag as we have many bags and many weapons. The pattern stays the same. <tt style="background-color: #b0e0e6;">^pwb</tt> The ^ at the beginning of the line means that the command starts with pwd and no other letter in front of this. If we define our pattern more clearly, the pattern will match less often. Without the <tt style="background-color: #b0e0e6;">^</tt> the alias will match and the alias script will always be run whenever there is the sequence of letters "pwd" in your commands. This may not always be what you want. This is why it&#8217;s usually a good idea to make the pattern definition as exact as needed by being <em>less</em> general. The more general the pattern, the more often it will match.</p></div>
<div class="paragraph"><p>Back to our task: The pattern is <tt style="background-color: #b0e0e6;">^pwb</tt>. Let&#8217;s assume that we have defined 2 variables in some other script. The variable "weapon" is the weapon we use and the variale "bag" is the name of the bag. NOTE: In Mudlet global variables can be accessed anywhere from within Mudlet scripts - no matter if they have been defined in a trigger script, in an alias script or in a key or button script. As soon as it&#8217;s been defined it somewhere it is usable. To make sure that a variable is local only, i. e. cannot be referenced from other scripts, you have to use the keyword local in front of your variable definition.
Back to our alias: Pattern is:<tt style="background-color: #b0e0e6;">^pwb</tt> Script is:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send( "put " .. weapon .. " in " .. bag )</tt></pre>
</div></div>
<div class="paragraph"><p>Depending on the values of our variables Weapon and bag the command "<sup>pwd" will be substitued with an appropriate command.
To set your weapon and bag variables we use 2 more aliases:
Alias to set the weapon: <tt style="background-color: #b0e0e6;"></sup>uw (\w</tt>)+
Script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>weapon = matches[2];
send( "wield " .. weapon )</tt></pre>
</div></div>
<div class="paragraph"><p>To set our bag variable:
Pattern:<tt style="background-color: #b0e0e6;">^set bag (.*)"</tt></p></div>
<div class="listingblock">
<div class="content">
<pre><tt>bag = matches[2]</tt></pre>
</div></div>
<div class="paragraph"><p>Now let&#8217;s go back to our initial problem. We want an alias to put our current weapon into our current bag. But what happens if we are in the middle of a fight and absolutely need to sip a healing potions because we are close to death and cannot take the risk that the bag may be too full to take the weapon? We want to upgrade out little alias to take into account that the bag may be full and chose an empty bag instead. To do this we set up a trigger that detects messages that indicate that the attempt to put the weapon in the bag failed. In this trigger we execute this little bag-is-full-detection-trigger
Trigger Pattern: (type substring) "Your bag is full."
script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>bagIsFull = true;</tt></pre>
</div></div>
<div class="paragraph"><p>This detection trigger will set the variable bagIsFull to true as soon as it sees the message "Your bag is full.". Then you know that you have to use your spare bag to take the weapon.</p></div>
<div class="paragraph"><p>Now we have the tools to write an improved version of our little alias script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>if bagIsFull then
    send( "put " .. weapon .. " in " .. spareBag )
else
    send( "put " .. weapon .. " in " .. bag )
end</tt></pre>
</div></div>
<div class="paragraph"><p>The next example is one of the most common aliases a tell alias:
Pattern:<tt style="background-color: #b0e0e6;">^tj (.*)"</tt>
Script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send( "tell Jane " .. matches[2]</tt></pre>
</div></div>
<div class="paragraph"><p>Sadly, Jane is your fiance and the one thing she is a vegetarian and absolutely hates all words that relate to meat.
Luckily, you know enough about aliases by now to make her believe that you&#8217;d never ever even think about meat. So you head to your globa function script (any script item will do as long as you define your variables <strong>outside of</strong> your function definitions. See the scripts chapter below for more information.
In your script "my global functions" you add a Lua table containing a list of all of all words that a vegetarian might hate.
For example: happyJaneTable = { "meat", "burger", "steak", "hamburger", "chickenburger" }
Now you can upgrade your tell-jane script to automatically filter all words that Jane might not like.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt></tt></pre>
</div></div>
</div>
<h2 id="triggers">Mudlet&#8217;s Trigger Engine</h2>
<div class="sectionbody">
<h3 id="_simple_trigger_matching">Simple Trigger Matching</h3>
<div class="paragraph"><p>Type your trigger in the input line below the trigger conditions list box and then press add to add it to the list. You can edit an expression in the list by clicking on it and then edit it on the input line below. After your edit you have to press the return key to accept the changes.
After editing is finished your changes will only become permanent if you press on the save icon on the upper left. This is the same throughout the entire program. If you forget to save your current changes or new additions, they will be lost once you select to edit some other item.
Select the trigger type from the listbox below the expression line edit. Normal substring matching will do for most people and it is the fastest matching type available.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p>Example: You want to trigger on the word "pond" in a line such as: "The frog swims in the pond. Plop." All you need to do is enter "pond" in the trigger expression input line and add it to the expression list. Then enter the command you like to send to the MUD if the trigger matches e.g. "drink water" and then you are done. The more advanced trigger types are explained below.</p></div>
</div></div>
<h3 id="_simple_highlighter_triggers">Simple Highlighter Triggers</h3>
<div class="paragraph"><p>If you want to highlight the word "pond" in the above example you have to add the following little Lua script to the script editor on the lower right side of the Script Editor window:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString( "pond", 1 )
fg( "red " )
bg( "blue" )</tt></pre>
</div></div>
<h3 id="_and_and_or_condition_triggers">"AND" and "OR" Condition Triggers</h3>
<div class="paragraph"><p>AND -Triggers execute their respective command or script only if all conditions in their respective conditions expression list are fullfilled.
OR-Triggers execute when <strong>any</strong> one of their conditions is true.
To make OR-Triggers you simply have to add a few conditions to the conditions list e.g. in our example: "pond", "frog", "Plop". The trigger will now also execute on lines like this: "A frog is green" or "You hear a loud Plop!" However, it will not execute on "With a loud plop the frog dived into the water." because "plop" in the line is in lower case letters and your condition specified a "P" in upper case.
The simplest form of AND-Triggers in Mudlet are Trigger Chains or Filter Chains, whatever you&#8217;d like to call it.</p></div>
<h3 id="_trigger_chains_filter_chains">Trigger Chains - Filter Chains</h3>
<div class="paragraph"><p>Imagine the following scenario: You want to collect some berries. You know that the room contains some berries if the room description contains the words "You see several sorts of berries." You make a new substring trigger for this line, but instead of chosing a regular trigger, you chose to add a new trigger group. Now you add "You see several sorts of berries." to the expression list of the trigger group. When adding condions to a trigger group, the trigger group turns from an organizational unit into a filter unit. From now on this folder is a filter and will only let data through that matches it&#8217;s condition.
In our case this is exactly what we want, because we don&#8217;t want to collect all sorts of berries, but we only want 2 particular kinds, namely, strawberries and blackberries. Now you add two regular triggers to our berry filter - one containing the condition: "strawberries" and the other one "blackberries". Then we add the commands to pick the particular kind of berry to both triggers.
Now what happens is that as soon as a room description reads "You see several sorts of berries." the filter will let the line containing the room description pass through to our two berry triggers and they will issue commands to pick berries. However, in any other situation the words "strawberries" and "blackberries" will <strong>NOT</strong> trigger - only in the above scenario when the filter parent&#8217;s condition is met. This is a very nice way to solve complicated problems with a few easy filter chains. This example is trivial, but using filter chains will rapidly show you how formerly complicated things that could only be solved with very complicated regular expressions can be solved easily now with a couple of filter chains.</p></div>
<h3 id="_multi_line_triggers_and_multi_condition_triggers">Multi-Line Triggers and Multi-Condition Triggers</h3>
<div class="paragraph"><p>Multi Condition Triggers are the most advanced feature of Mudlet&#8217;s trigger engine. Like trigger chains or filter chains they are a form of AND-Triggers.
All conditions in the list must have matched within the specified margin of lines (delta), in order to trigger the script.
Normal triggers fire and run the script as soon as one of the conditions in the regex list is met i.e. if one of the regex/string matches match - or the Lua function condition return true, the trigger script is run.
In multiline triggers, however, each single regex/string/Lua function condition in the list has to have matched within the specified margin of lines at least once to trigger the script. The sequence of the conditions is binding. This means if the 10th regex on the regex list would be matched on the eleventh line after the match of the first line happened, the trigger will <strong>NOT</strong> run unless the margin of lines is set to 11. If condition #3 is true but currently #2 is waiting to be true, condition #3 is ignored and must be true again after condidtion #2 has been true.
Conditions can also be Lua Functions that return a boolean truth value. You can mix all types of condtions.</p></div>
<div class="paragraph"><p>Example: Let&#8217;s go back to our pond &amp; frog example. We have explained the difference between AND-triggers and OR-triggers. If you have a room description consisting of 3 lines:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>1. You see a pond
2. You see a frog.
3. The frog sits on a stone.</tt></pre>
</div></div>
<div class="paragraph"><p>Every single one of these 3 lines will be fed into the trigger engine one after another. If we define an OR-trigger with a condition list consisting of 3 condition patterns:</p></div>
<div class="paragraph"><p>condition #1 pattern = pond
condition #2 pattern = frog
condition #3 pattern = stone</p></div>
<div class="paragraph"><p>Wheather or not a condition is found to be true <strong>also</strong> depends on another property, i.e. the <strong>type</strong> of the condition.
The condition type can be among others:</p></div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic"><ol class="arabic">
<li>
<p>
substring matching  &#8594; the condition is true if the condition pattern is a substring of the output line from the MUD. In other words: If the pattern "pond" is contained in any line of output, the condition is true.
</p>
</li>
<li>
<p>
begin of line matching &#8594; the condition is only true if the conditon pattern can be found at the beginning of a line from the MUD.
</p>
</li>
<li>
<p>
Perl regular expression &#8594; the condition is true if the Perl regex pattern is matched. You&#8217;ll find more information on Perl regex below.
</p>
</li>
</ol></div>
</div></div>
<div class="paragraph"><p>In our example we chose condition type "substring" for all three condtions.
Consequently, the trigger will fire the command or script 3 times i. e. the trigger will execute on each line it is matched against because in every line at least one condition evaluates to true because the pattern is a substring of the line.</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>in line #1 we get: pond = true.
in line #2 we get frog = true and
in line #3 two conditions are true i.e. frog=true and stone = true</tt></pre>
</div></div>
<div class="paragraph"><p>Because an OR-trigger fires on the first condition that is true and ignores the rest the trigger will only execute 3 times on these 3 lines although 4 conditions are true.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img alt="Caution" src="data:image/png;base64,
iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAKdUlEQVRoge1Ze1AV1x3+zt279wEi
DWCYGzRVktqa1MEmmtbWR22ncXxUrTDWV/5IqG2wUAUfmUwSkk6V+EAJCEQC6figwZBqZtRxqukf
tebRZBpFG1S0hiRErwiaKK977+6eX//YPXt37+UiIJlMZnpmdnb33PP4vt97z2VEhG9yc3zdAO60
/Z/A192+8QScX8Wifr+fWltbzffU1FT4fD72Vew15ASampqovr4eBw8eNPvGjRuHzMxMmj9//tCT
IKIhu958801yuVwEoNdr48aNNJT7EdHQEdi/fz/JshwTvLiKioqGlMSQLFJfX0+MMRvQsWNSqXLz
H2jez78fRWLTpk1DRuKOF6irqyOn02kDOP8XGdTz+VFSP91Hatu79NRvZ0SR2LJly5CQuKPJtbW1
JEmSDdivHp1AwctHSblYSsqFElLOF5PavIvWZU+LIrF169Y7JjHoibt3744CnzXrIQpeOUbKhVJS
mkpIPV9MyrnNpJwtIuVSNa15/MdRJLZt23ZHJBjRwIu5N954gxYvXgzOudm3aO5E1L5SBNZ1Hoxr
INLAyH6HJxVP/WkXtu9+37ZeSUkJVq9ePagQO+BMXFNTEwV+ybxHsPeVIjg6zwOkgSWNhuOuUUBC
KhxJY0AggDSgpwWbn1mO1csftq1ZUFCA0tLSQZXFA0pkVVVVlJOTA6vWsmY9hF07N0AS4OU48LgR
WLO+FPFxboxMS8G5hlPYmPMI4jwM1P0Jtj67DJyrKHvtNADdjPPz8+FwOCgvL29gmuivrVVUVESF
yqxZD1PoyjFSL+7QHbapmJTml+n9EzVRtl676ZekNKwl5VQ+KSfzKHR2E+UutodYxhiVl5cPyCf6
ZUJlZWWUm5trk/wTi6bgtVdf1M2Gq2DEwUgDNBWhUDBqjfSRwwGoIOEP3c3Y/uxirFw0zibMvLw8
VFZW9tucbkugoqKCVq1aZQO/YslUVJU+D9bVBIDroLgK4hygEDweybYGY8AD6d8yftfASL+j+2O8
9NwiPJk51kYiNzcXO3fu7BeJPgkUFxdTbm6ure/JZdNRub0QrOMcGFcBrgLgAHEAGqD2ID7OZZsz
Ji0RcR6HAV4DkaqPJxXouoSywkz8buF9NhIrV65EVVXVbUnEJHDixAlat26drS9n+U+xo/hZMMNh
yZA+uAbAIKOGMCJlmG3eA/clAYaJEamGBlRdC6QBXZewo3AhVswfbSORk5ODDz/8sE8SvRLw+/1U
XV0dBb5MgOe6LUNIEqpOwgCUlOCESw4HuAfG3KX7B2kAGaTJ0Jro77yI8ucX4DfzRtlIHD58GH6/
PyaJXgk0NjZi79695vuUiffrkr91Vt8cHAwc4FZJGiZEKqDcwsi0ZHP+d749POy8MS7iGtBxARWF
8/CDsQnm3BdeeAHWj6N+EYhspSVbgI5zYYkZGmAwzIEbwA0tUM9NfO+7aeb89HuGRQBWLcSNZxj3
zvOYMzk5NpjBEHi99mXD5lXdjqGDJh42h7CEOXhnK3448X5z/shUb1jSpIEM8yFuzOUcjAsNcnR0
KXdG4MEHH8TEiRPN9z0H3sfRE41m+GNcs9i0LjkGTTcrUoGem5g7/V5z/ohElw4O+jxGYQ3qJqmB
jN/+cbINtcfCJvPYY4+hr3qtVwI+n49lZmaa71fbbuH3hX/FycbPQKSCoIIMQEQcehjVo5Gw8/F3
3cSvH03H2HuHY1icQzcvYWKGIMiITMwQwjtnruPpqk9w/ZZq7p2RkYEJEyaAYrCIWY36/X7KyMhA
W1ub2XfP3Qmo3ZKFaQ+P0gmYIdSoOkU4lWSwxGRAdqHL/xm86k27w0blAw3/PncD6yo/xrsfdZj7
paSkoLGxESNGjAgDZsxWK8X0AZ/Px44fP460tLAzXrnWgUX5r+PYuxf1mG/Gf80sofWy2YuWbg/+
uONtPLHhPRw+0WIHL8hbwG95rcUGPiEhAYcOHUJSUhI456YZRWqiz+8BIqLm5mZMmjQJN27cMPsT
E9zYtWE25k4bYzh3mABIBRwOHPgPx+LH/6yDiXPi6pHZcEpk+I5qmtGpCzdQecCPPUevmevLsowj
R45gypQpcDgc5mVowKaJmBoQTEePHo2GhgaMGxcuum52BLHsqUOoP3oWgLB9Sz7QgpgxJoThw/SS
IutnaXBKZEpcgD998Uvs+3ubDbzT6URNTQ0mTZoEVVWhaRo459A0TeCy4etVA+JH8RvnHK2trZgz
Zw5Onz5tjnPJDrxSOAPLZt1nSVIqwDmIVJw6dx1nLt3A3J/cjZThkhE29cvf3o2KA59ja91lcz3G
GDZv3oylS5fC7XbD6XTC6XRCkiRIktS7Jm5HQLDXNA3Xr19HVlYWPvjgA4vEGLav+RHmTxsJX4rb
8AsO4kbOIG6GzTD4HvzlmB/PVH9q2zc/Px/Z2dnwer1wu92QZRkulwuSJEGWZZMEY8wkEGVCVvCC
AOcciqIgPj4e+/btw9SpU83xqkpYteU9HHm7Bf62rnC2RjikisTFSMPV9m4ceucannvVDn7p0qVY
uHAhgsEggsEgQqFQlAlZnVm0PjOxIKFpGogIqqrC5XKhuroa06dPt4wDcl78F+qPNeNKe6cRoTjs
ZYOKK+3dON7wBQrKm2H5pMbMmTOxZMkSBAIB9PT0oKenB4FAAIqiQFEUU4hRRyq3I2AlIZ4553A6
nSgvL8fs2bNtY9eVNaDub58YmhDZWpe+v70bJ5tu4clt/4WihqU4efJkrFixAkRkAg4Gg1AUBaqq
muDF/pGtX7WQNXeIZ0mSUFRUhAULFtjGPl3ZiJdev4QrbZ16zUQqrrZ342JLN5ZvaEJ3ICz68ePH
IycnB5qmmZIW4EOhUJTZWEKo+Rx1KsEYY9Zk4XA4IEmSKXnOuRkVJElCYWEhvF4v6urqzDVK9n2M
zu4Qnl5+L9q/7MHltgBWbr9kA5+eno7c3FzIsoyI5GrTeCzgosU8VmGMmSGLiEwSsixH2WNBQQEA
2EhUH/wc7330BaaOH479/2zHtS/CFabP58OaNWvg9Xp1EE4nZFmGLMtwu93wer1wuVy2ECpJko2I
iTNWJrZGI+HEwi6FisUVCAQQCASwZ88eVFZW9lk9JicnY/369fD5fPB4PCbo+Ph4k4TH44HL5YLX
64XX6zXH9EKE9aUBRkTEGLNJP1Kd4nI4HMjOzkZ8fDyKi4ttJ3eiJSYmYu3atRg1apQJzuv1wuPx
wOPxwOFwmEBFHnA6nXC5XGYSiywlbns2SnoDANN0hMNZnS0UCpkaOnPmDN566y20tLSY2ktLS8OM
GTOQkpICt9uNuLg4M2EJ8CJZSZJkZmFBwkrAWpH2+3BXEBEkRIhTVdVMOCL5qKqKy5cvQ1EUaJoG
VVWRnKx/Jlpt3eVy2QCKu9C68AFr9o0spwd0Oh1ZYggCIlNaiQktiXdhZgKQABcp3ci7LMtM7B0J
fsAErJoAYItG1mdr+hfvVlACtHDIXkploYXbHvQOikDEe6/ZmjFmAhf9ZvJxOk2Qol88W4kYz32S
GNQfHLG+TyMTkAVEr88xQfVnkBg7GAKixSIykDYQsL21/wFkW/B5QqT9lwAAAABJRU5ErkJggg==" />
</td>
<td class="content">The multiline condition switch must be turned off to get an OR-trigger! If the multiline condition switch is turned on the trigger becomes and AND trigger which means that the trigger only fires if all conditions are true and fullfilled in the correct sequence. With OR-triggers the sequence is irrelevant.</td>
</tr></table>
</div>
<div class="paragraph"><p>To complicate matters, however, you don&#8217;t want your trigger to fire 3 commands, because you want to use this room description as a whole to fire your trigger e. g. this pond is the only kind of ponds in the entire world that doesn&#8217;t have poisoned water. So you want to make sure that you only drink water from a pond of this kind and from no other pond. Your solution is to use Multi Conditon Triggers. If you check the MCT checkbox this trigger will fire only once from now on - and only if all conditions are met i e. you can guarantee that you only drink water from a good pond because your drinking trigger is matching on the entire room description.</p></div>
<div class="paragraph"><p>Sadly, there are many unfriendly people in this world and somebody goes around and poisons your good ponds. Consequently, you would want to examine the frog and find out if it is poisoned before drinking water from the pond. This is difficult because the villain is a mean magician who used illusion spells to make everything look like the good pond. To solve the problem you can now resort to Lua function conditions in the trigger condition list that perform certain check ups to put the current room description into a wider context e. g. check if you have been here before etc. This adds yet another level of complexity to your problem but this is a very powerful means to use the full potential of Mudlet&#8217;s MCTs.</p></div>
<div class="paragraph"><p>You can combine all forms of conditions with trigger chains, filters and Lua functions. Mudlet gives you relatively easy to use tools that require no programming background. However, these tools can evolve into complex powerful problem solving mechanisms if they are combined with each other thus enabling non-programmer users to solve problems that would need a profound programming background in other MUD clients.</p></div>
<h3 id="_temporary_triggers_scripting_only">Temporary Triggers (scripting only)</h3>
<div class="paragraph"><p>Temporary triggers are lightweight triggers that are tailored for typical scripting needs. These are only available via Lua scripting. They are not stored in profiles, but stay in memory as long as the program runs or until they are deleted (killTimer()).</p></div>
<h3 id="_line_triggers_scripting_only">Line Triggers (scripting only)</h3>
<div class="paragraph"><p>Line triggers trigger on a specified line in the future - or a sequence of lines - irrespective of the content of the line. This type of triggers can be very handy in scripting if you know what is coming e.g. you want to parse a table from the MUD, maps etc.</p></div>
</div>
<h2 id="timers">The Timer Engine</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet supports 3 different sort of timers:</p></div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<em>Regular GUI Timers</em> that fire repeatedly in a certain interval specified by the user.
</p>
</li>
<li>
<p>
<em>Offset Timers</em> are child timers of a parent timer and fire a single shot after a specified timeout after their parent firied its respective timeout. This interval is an offset to the interval of its parent timer. Example: parent timer fires every 30 seconds and by doing so kicks off 3 offset timers with an offset of 5 seconds each. Consequently, the 3 children fire 5 seconds after each time the parent timer fired. Offset timers differ visually from regular timers and are represented with a + icon for offset. Offset timers can be turned on and off by the user just like any other timer.
</p>
</li>
<li>
<p>
<em>Temporary Timers</em> that very useful for scripting. They behave like regular timers, but they are one shot only timers. Temporary timers can not be accessed from the GUI and are not saved in profiles.
</p>
</li>
</ol></div>
</div></div>
</div>
<h2 id="buttons">Buttons and Custom User Toolbars</h2>
<div class="sectionbody">
<div class="paragraph"><p>Buttons are co</p></div>
</div>
<h2 id="scripting">Scripting with Mudlet</h2>
<div class="sectionbody">
</div>
<h2 id="luaSyntax">A quick Lua syntax overview</h2>
<div class="sectionbody">
<div class="paragraph"><p>Lua variables can be either a string or a number. They are whatever there were initially initialized with.
=== string concatenation, variable substitution)</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>a = "Jim"
b = "Tom"
c = 350
d = 1</tt></pre>
</div></div>
<div class="paragraph"><p>Then you can write:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>e = c + d and e will equal 351
e = a .. b and e will equal "JimTom" note that you cant use a+b to concatenate string values. For this you must use ..
e = a .. c and e will equal "Jim350"</tt></pre>
</div></div>
<div class="paragraph"><p>Lua tables can basically be considered multidimensional arrays and dictionaries at the same time.
If we have the table matches, matches[1] is the first element, matches[n] the n-th element.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>a = "Tom"
matches[1] = "Betty"
b = matches[1]
c = a .. b and e will equal "TomBetty"</tt></pre>
</div></div>
<div class="paragraph"><p>To output a table you can use a conveniance function printTable( name ). This function is defined in LuaGlobal.lua and can be found in your home directory under ./mudlet (note the leading dot ) Profiles and mudlet_documentation.html are stored in this directory as well.</p></div>
</div>
<h2 id="_lua_interface_functions_to_mudlet_or_how_do_i_access_triggers_timers_etc_from_lua_scripts">Lua interface functions to Mudlet - or how do I access triggers, timers etc. from Lua scripts</h2>
<div class="sectionbody">
<div class="paragraph"><p>How to get data from regex capture groups?
Regular expression capture groups (e.g. â€ž(\d+)â€œ ) are passed on to Lua scripts as a Lua table matches.
To make use of this information inside Lua scripts, you need to specify the number of the capture group within the regex.</p></div>
<div class="paragraph"><p>Example: You have (\d+) weapons and they are (?:(\b\w+\W+)+)</p></div>
<div class="paragraph"><p>This regex contains 3 capture groups, but only the 2 green colored ones contain data as the red capture group is a non-capturing group. Consequently, your Lua script gets passed only 2 instead of 3 capture groups and matches[3] is undefined.</p></div>
<div class="paragraph"><p>In your Lua script you may write following program in order to print the number and status of your weapons on the screen:</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p>You have (\d+) weapons and they are (?:(\b\w+\W+)+)</p></div>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>number_of_weapons = matches[1]
status_of_weapons = matches[2]
notice = number_of_weapons .. status_of_weapons
echo( notice )
send( â€žput weapons in backpackâ€œ )

-- the following 2 lines color the first capture
-- group red and the second group blue
-- see below for details

selectCaptureGroup( 1 )
setFgColor( 255,0,0 )

selectCaptureGroup( 2 )
setFgColor( 0,0,255 )</tt></pre>
</div></div>
<div class="paragraph"><p>The best way is to use selectCaptureGroup( number ) to select the proper capture group and then perform your actions on it e.g. replace(), colorize etc. Note: Both selectCaptureGroup() and matches[n] start with group 1.</p></div>
<div class="paragraph"><p>How to select all occurrences of "Tom" and colorize them?</p></div>
<div class="paragraph"><p>You add a functon like this to a script conataining you main function definitions. Note that script items differ from all other "scripts" in triggers, timers, actions etc. because they require you to put your code in proper functions that can be called by your other trigger-scripts, timer-scripts etc. via normal function calls. Trigger-scripts, timer-scripts etc. cannot contain any function definitions because they are automatically generated functions themself because this makes usage a lot easier.</p></div>
<div class="paragraph"><p>To come back to our question how to select all occurrences of "Tom" and colorize them:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>function setBgColorAll( word, r, g, b )
    i = 0
    word_count = 1
    while i &gt; -1 do
        i = selectString(word, word_count)
        if i == -1 then
             return
        end
        word_count = word_count +1
        setBgColor( r, g, b )
    end
end</tt></pre>
</div></div>
<div class="paragraph"><p>Then you simply define a substring matching trigger on the word "Tom" and in the trigger script you call above function:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>setBgColorAll("Tom", 255,50,50)</tt></pre>
</div></div>
<h3 id="_sending_commands_to_the_mud_or_printing_information_messages_on_the_screen">Sending commands to the MUD or printing information messages on the screen</h3>
<div class="paragraph"><p>To print information messages on the session screen you can use the echo( message ) function, or insertText( text). Currently, it only takes one string as argument.</p></div>
<div class="paragraph"><p>To send a command to the MUD, you can use the send( command ) function. Note: everything you send via send() will be processed by the alias processing unit.
In Alias scripts the command that is being sent to the MUD is contained in the variable command that you can change in the context of Alias scripts.
Alias take regular expressions, as well. As a result, you can use following regex and script to talk like Yoda:
Perl regex:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>say (\w+).*(\w*).*(.*)</tt></pre>
</div></div>
<div class="paragraph"><p>script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send( "say " .. matches[3] .." " .. matches[1] .." ".. matches[2] )</tt></pre>
</div></div>
<div class="paragraph"><p>Note: The variable "command" contains what was entered in the command line or issued via the expandAlias( ) function. If you use expandAlias( command ) inside an alias script the command would be doubled. You have to use send( ) inside an alias script to prevent recursion. This will send the data directly and bypass the alias expansion.</p></div>
<h4 id="_changing_text_from_the_mud_or_reformatting_text_colorize_make_bold_etc">Changing text from the MUD or reformatting text (colorize, make bold etc.)</h4>
<div class="paragraph"><p>When sending commands to the MUD - from now on referred to as output stream - alias scripts find the command that whas issued by the user stored in the variable "command".</p></div>
<div class="paragraph"><p>By manipulating the value, the command can easily be changed before it is being sent to the MUD.</p></div>
<div class="paragraph"><p>However, things get much more complicated with the data received from the MUD â€“ from now on referred to as input stream. Before triggers can be run on the MUD data Mudlet has to strip all format codes from the text and store it in data structures associated with the text. Consequently, the text that is being passed on to the trigger processing unit is a small subset of the data received from the MUD. If you want to edit, replace, delete or reformat text from within your trigger scripts you have to keep this in mind if you don&#8217;t want to lose all text format information as colors etc.</p></div>
<div class="paragraph"><p>As the text is linked with data structures containing the format of the text, the cursor position inside the line is important if data is being changed. You select a word or a sequence of characters from the line and then issue commands to do actions on the selected data.</p></div>
<div class="paragraph"><p>Replacing the word "Tom" with "Betty" in the line: Jim, Tom and Lucy are learning a new spell. Could be done with following script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString("Tom",1)
replace("Betty")</tt></pre>
</div></div>
<div class="paragraph"><p>Things get more complicated if there are two or more occurrences of "Tom" in the line e. g. Jim and Tom like magic. Jim, Tom and Lucy are learning a new spell.</p></div>
<div class="paragraph"><p>The above example code would select the first occurrence of "Tom" in this line and ignore the second.
If you want to work on the the second occurrence of "Tom" you have to specify the occurrence number in the call to select().</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString( "Tom", 2 )
replace( "Betty" )</tt></pre>
</div></div>
<div class="paragraph"><p>This code would change the second "Tom" and leave the first "Tom" alone. The function call</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>replaceAll( "Betty" )</tt></pre>
</div></div>
<div class="paragraph"><p>will replace all occurrences of "Tom" with "Betty" in the line if "Tom" has been selected before. ReplaceAll() is a conveniance function defined in LuaGlobal.lua.</p></div>
<div class="paragraph"><p>Colorization example: You want to change to color of the words ugly monster to red on a white background.</p></div>
<div class="paragraph"><p>You add a new trigger and define the regex: ugly monster
In the script you write:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString("ugly monster", 1 )
setFgColor(255,0,0)
setBgColor(255,255,255)</tt></pre>
</div></div>
<div class="paragraph"><p>Another means to select text is to select a range of characters by specifying cursor positions.
If we have following line: Jim and Tom like magic. Jim, Tom and Lucy are learning a new spell.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectSection( 28, 3 )</tt></pre>
</div></div>
<div class="paragraph"><p>This example would select the second Tom. The first argument to selectSection is the cursor position within the line and the second argument is the length of the selection.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectCaptureGroup( number )</tt></pre>
</div></div>
<h3 id="_deleting_text_gagging">Deleting Text - Gagging</h3>
<div class="paragraph"><p>This function selects the captureGroup number if you use Perl regular expressions containing capture groups. The first capture group starts with index 1.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>deleteLine()</tt></pre>
</div></div>
<div class="paragraph"><p>This function deletes the current line - or any line where the cursor is currently placed. You can use repeated calls to this function to effectively erase the entire text buffer.
If you want to delete or gag certain words only, you can select the text that you want to delete and then replace it with an empty string e.g:</p></div>
<div class="paragraph"><p>If you get this line form the MUD: "Mary and Tom walk to the diner."</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString( "Tom", 1 )
replace( "" );</tt></pre>
</div></div>
<div class="paragraph"><p>Then the output will be changed to: "Mary and walk to the diner."</p></div>
<h3 id="_cursor_movement_and_cursor_placement">Cursor Movement and Cursor Placement</h3>
<div class="paragraph"><p>moveCursor( windowName, x, y )
This will move the user cursor of window windowName to the absolute (x/y) coordinates in the text.</p></div>
<div class="paragraph"><p>moveCursor( "main", 20, 3950 ) will move the cursor on the 20th character from the left on line number 3950.
To determine the current cursor position you can use getLineNumber() and getColumnNumber() as well as getLastLineNumber() to get the number of the last line in the text buffer. moveCursorEnd("main") will move the cursor of the main display to end of the buffer. This is always a new line of size 1 containing the character <em>\n</em>.</p></div>
<div class="paragraph"><p>number_of_last_line_in_text = getLineCount()</p></div>
<div class="paragraph"><p>returns the number of the last line of the text in the console buffer. This number will change as soon as a new <em>\n</em> is printed either by the user or</p></div>
<div class="paragraph"><p>when a new line arrives from the MUD. All lines from the MUD are terminated with <em>\n</em> which is called line feed or the new line character. This control character ends the current line and move the cursor to the beginning of the next line, thus creating a new, empty line below the line that contains the <em>\n</em>.</p></div>
<div class="paragraph"><p>line_number_of_the_current_cursor_position = getLineNumber()</p></div>
<div class="paragraph"><p>column_number_of_the_current_cursor_position = getColumnNumber()</p></div>
<div class="paragraph"><p>luaTable_containing_textlines = getLines( absolute_line_number_from, absolute_line_number_to )</p></div>
<div class="paragraph"><p>this will return a Lua table containing all lines between the absolute positions from and to. NOTE: This function uses absolute line numbers, not relative ones like in moveCursor(). This little demo script shows you how to use cursor functions:</p></div>
<div class="paragraph"><p>moveCursor() return true or false depending on wheather the move was possible.</p></div>
<div class="paragraph"><p>User defined dockable windows</p></div>
<div class="paragraph"><p>You may want to use dock windows to display information you gathered in your scripts, or you may want to use them as chat windows etc.
Adding a user defined window:</p></div>
<div class="paragraph"><p>openUserWindow( string window_name )</p></div>
<div class="paragraph"><p>echoUserWindow( string window_name, string text )</p></div>
<div class="paragraph"><p>setWindowSize( int x, int y )</p></div>
<div class="paragraph"><p>clearWindow( string window_name )</p></div>
<div class="paragraph"><p>Dynamic Timers</p></div>
<div class="paragraph"><p>tempTimer( double timout, string lua_code_to_execute, string/float/int timer_name )
disableTimer( name )
enableTimer( name )</p></div>
</div>
<h2 id="_dynamic_triggers">Dynamic Triggers</h2>
<div class="sectionbody">
<div class="paragraph"><p>triggerID = tempTrigger( regex, code ) creates a fast substring matching trigger
triggerID = tempRegexTrigger( regex, code ) creates a regular expression matching trigger</p></div>
</div>
<h2 id="events">Registering Event Handlers and Raising Events</h2>
<div class="sectionbody">
<div class="paragraph"><p>raiseEvent( string name, args )</p></div>
</div>
<h2 id="_handling_tables_in_lua">Handling Tables in Lua</h2>
<div class="sectionbody">
<div class="paragraph"><p>Nick Gammon has written a very nice overview on how to deal with Lua tables. You can find it here: <a href="http://www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=6036">http://www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=6036</a>.</p></div>
<div class="paragraph" id="example1"><div class="title">How to use multilinematches[n][m]</div><p>(The following example can be tested on the MUD batmud.bat.org)</p></div>
<div class="paragraph"><p>In the case of a multiline trigger with these 2 Perl regex as conditions:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>^You have (\w+) (\w+) (\w+) (\w+)
^You are (\w+).*(\w+).*</tt></pre>
</div></div>
<div class="paragraph"><p>The command "score" generates the following output on batMUD:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>You have an almost non-existent ability for avoiding hits.
You are irreproachably kind.
You have not completed any quests.
You are refreshed, hungry, very young and brave.
Conquer leads the human race.
Hp:295/295 Sp:132/132 Ep:182/181 Exp:269 &gt;</tt></pre>
</div></div>
<div class="paragraph"><p>If you add this script to the trigger:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>showMultimatches();</tt></pre>
</div></div>
<div class="paragraph"><p>The script, i.e. the call to the function showMultimatches() generates this output:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt> -------------------------------------------------------
 The table multimatches[n][m] contains:
 -------------------------------------------------------
 regex 1 captured: (multimatches[1][1-n])
           key=1 value=You have not completed any quests
           key=2 value=not
           key=3 value=completed
           key=4 value=any
           key=5 value=quests
 regex 2 captured: (multimatches[2][1-n])
           key=1 value=You are refreshed, hungry, very young and brave
           key=2 value=refreshed
           key=3 value=young
           key=4 value=and
           key=5 value=brave
 -------------------------------------------------------</tt></pre>
</div></div>
<div class="paragraph"><p>The function showMultimatches() prints out the content of the table multimatches[n][m].
You can now see what the table multimatches[][] contains in this case. The first trigger condition (=regex 1) got as the first full match "You have not completed any quests". This is stored in multimatches[1][1] as the value of key=1 in the sub-table matches[1] which, in turn, is the value of key=1 of the table multimatches[n][m].</p></div>
<div class="paragraph"><p>The structure of the table multimatches:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>multimatches {
                1 = {
                       matches[1] of regex 1
                       matches[2] of regex 1
                       matches[3] of regex 1
                              ...
                       matches[n] of regex 1 },
                2 = {
                       matches[1] of regex 2
                       matches[2] of regex 2
                             ...
                       matches[n] of regex 2 },
                 ...         ...
                n = {
                       matches[1] of regex n
                       matches[2] of regex n
                             ...
                       matches[n] of regex n }
}</tt></pre>
</div></div>
<div class="paragraph"><p>The sub-table matches[n] is the same table matches[n] you get when you have a standard non-multiline trigger.
The value of the first key, i. e. matches[1], holds the first complete match of the regex. Subsequent keys hold the respective capture groups.
For example:
Let regex = "You have (\d+) gold and (\d+) silver" and the text from the MUD = "You have 5 gold and 7 silver coins in your bag."
Then matches[1] contains "You have 5 gold and 7 silver", matches[2] = "5" and matches[3] = "7".
In your script you could do:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>myGold = myGold + tonumber( matches[2] )
mySilver = mySilver + tonumber( matches[3] )</tt></pre>
</div></div>
<div class="paragraph"><p>However, if you&#8217;d like to use this script in the context of a multiline trigger, matches[] would not be defined as there are more than one regex.
You need to use multimatches[n][m] in multiline triggers. Above script would look like this if above regex would be the first regex in the multiline trigger:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>myGold = myGold + tonumber( multimatches[1][2] );
mySilver = mySilver + tonumber( multimatches[1][3] );</tt></pre>
</div></div>
<div class="paragraph"><p>What makes multiline triggers really shine is the ability to react to MUD output that is spread over multiple lines and only fire the action (=run the script) if all conditions have been fulfilled in the specified amount of lines.</p></div>
</div>
<h2 id="api">Lua API</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet defines several global Lua variables that are accessible from anywhere.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="hsides"
cellspacing="0" cellpadding="4">
<caption class="title">Lua Variables</caption>
<col width="50%" />
<col width="50%" />
<thead valign="top">
<tr>
<th align="left">Variable Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td align="left"><p class="table">command</p></td>
<td align="left"><p class="table">This variable holds the current user command. This is typically used in alias scripts.</p></td>
</tr>
<tr>
<td align="left"><p class="table">line</p></td>
<td align="left"><p class="table">This variable holds the content of the current line as being processed by the trigger engine. The engine runs all triggers on each line as it arrives from the MUD.</p></td>
</tr>
<tr>
<td align="left"><p class="table">matches[n]</p></td>
<td align="left"><p class="table">This Lua table is being used by Mudlet in the context of triggers that use Perl regular expressions. matches[1] holds the entire match, matches[2] holds the first capture group, matches[n] holds the n-th capture group.</p>
<p class="table">If the trigger uses the Perl style /g switch to evaluate <strong>all</strong> possible matches of the given regex within the current line, matches[n+1] will hold the second entire match, matches[n+2] the first capture group of the second match and matches[n+m] the m-th capture group of the second match.</p></td>
</tr>
<tr>
<td align="left"><p class="table">multimatches[n][m]</p></td>
<td align="left"><p class="table">This table is being used by Mudlet in the context of multiline triggers that use Perl regular expression. It holds the table matches[n] as described above for each Perl regular expression based condition of the multiline trigger. multimatches[5][4] may hold the 4th capture group of the 5th regex in the multiline trigger. This way you can examine and process all relevant data within a single script. Have a look at this <a href="#example1">example</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="hsides"
cellspacing="0" cellpadding="4">
<caption class="title">Lua API</caption>
<col width="50%" />
<col width="50%" />
<thead valign="top">
<tr>
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td align="left"><p class="table">clearUserWindow( window_name )</p></td>
<td align="left"><p class="table">Clears the user window with the name given as argument.</p></td>
</tr>
<tr>
<td align="left"><p class="table">copy()</p></td>
<td align="left"><p class="table">Copies the current selection to the clipboard. This function operates on rich text, i. e. the selected text including all its format codes like colors, fonts etc.</p></td>
</tr>
<tr>
<td align="left"><p class="table">cut()</p></td>
<td align="left"><p class="table">Cuts the current selection and stores it in the clipboard. This text remains available in the clipboard until it gets overwritten by another cut or copy operation. This function works on rich text ( see copy() )</p></td>
</tr>
<tr>
<td align="left"><p class="table">deleteLine()</p></td>
<td align="left"><p class="table">deletes the current Line under the user cursor.</p></td>
</tr>
<tr>
<td align="left"><p class="table"><strong>deselect()</strong></p></td>
<td align="left"><p class="table">deselects the last selected text</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableTimer( name )</p></td>
<td align="left"><p class="table">Use timer name or the id returned by tempTimer() to identify the timer that you want to disable.</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableTrigger( name )</p></td>
<td align="left"><p class="table">Use trigger name or the id returned by tempTrigger() to identify the timer that you want to disable.</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableKey( name )</p></td>
<td align="left"><p class="table">Uses trigger name as id or the id returned by tempTrigger()</p></td>
</tr>
<tr>
<td align="left"><p class="table">echo( text )</p></td>
<td align="left"><p class="table">prints text to the main window</p></td>
</tr>
<tr>
<td align="left"><p class="table">echoUserWindow( window_name, text )</p></td>
<td align="left"><p class="table">prints text to user dock window name</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableTimer( name )</p></td>
<td align="left"><p class="table">enables or activates a timer that was previously disabled. The parameter "name" expects the timer ID that was returned by tempTimer() on creation of the timer or the name of the timer in case of a GUI timer</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableTrigger( name )</p></td>
<td align="left"><p class="table">enables a Trigger. see enableTimer() for more details.</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableKey( name )</p></td>
<td align="left"><p class="table">enable key or key group "name"</p></td>
</tr>
<tr>
<td align="left"><p class="table">expandAlias( command )</p></td>
<td align="left"><p class="table">like send(), but without bypassing alias expansion. This function may lead to infinite recursion if you are not careful. This function can be used to make recursive alias expansion.</p></td>
</tr>
<tr>
<td align="left"><p class="table">lineNumber = getLineNumber()</p></td>
<td align="left"><p class="table">to get the absolute line number of the current user cursor</p></td>
</tr>
<tr>
<td align="left"><p class="table">number = getColumnNumber()</p></td>
<td align="left"><p class="table">To get the absolute column number of the current user cursor</p></td>
</tr>
<tr>
<td align="left"><p class="table">number = getLineCount()</p></td>
<td align="left"><p class="table">To get the absolute amount of lines in the current console buffer</p></td>
</tr>
<tr>
<td align="left"><p class="table">lua_table[relative_linenumber, content] = getLines( from_line_number, to_line_number )</p></td>
<td align="left"><p class="table">Returns a section of the content of the screen text buffer. Absolute line numbers are used</p></td>
</tr>
<tr>
<td align="left"><p class="table">number_of_last_line = getLineCount()</p></td>
<td align="left"><p class="table">number of the last line in the buffer</p></td>
</tr>
<tr>
<td align="left"><p class="table">insertText( string )</p></td>
<td align="left"><p class="table">Insertion takes place at the current position of the user cursor or replaces the current selection. Use deselect() to unselect unwanted selections to prevent overwriting.</p></td>
</tr>
<tr>
<td align="left"><p class="table">killTimer( name )</p></td>
<td align="left"><p class="table">Deletes a tempTimer. Use the Timer ID returned by tempTimer() as name parameter.</p></td>
</tr>
<tr>
<td align="left"><p class="table">killTrigger( name )</p></td>
<td align="left"><p class="table">See killTimer()</p></td>
</tr>
<tr>
<td align="left"><p class="table">boolean = moveCursor( windowName, x, y )</p></td>
<td align="left"><p class="table">Moves the user cursor of the window windowName to the absolute point (x,y). This function returns false if such a move is impossible e.g. the coordinates don&#8217;t exist. To determine tha correct coordinates use getLineNumber(), getColumnNumber() and getLastLineNumber(). The trigger engine will always place the user cursor at the beginning of the current line before the script is run. Use "main" for the main window and the name you called your user window otherwise.</p></td>
</tr>
<tr>
<td align="left"><p class="table">moveCursorEnd( windowName )</p></td>
<td align="left"><p class="table">Moves the cursor to the end of the buffer. "main" is the name of the main window, otherwise use the name of your user window.</p></td>
</tr>
<tr>
<td align="left"><p class="table">openUserWindow( name )</p></td>
<td align="left"><p class="table">Opens a user dockable console window for user output e.g. statistics, chat etc. If a window of such a name already exists, nothing happens. You can move these windows, dock them, make them into notebook tabs or float them.</p></td>
</tr>
<tr>
<td align="left"><p class="table">paste()</p></td>
<td align="left"><p class="table">pastes the previously copied or cut text including all format codes like color, font etc. at the current user cursor position. The copy(), cut() and paste() functions can be used to copy formated text from the main window to a user window without losing colors e. g. for chat windows, map windows etc.</p></td>
</tr>
<tr>
<td align="left"><p class="table">pasteWindow( name )</p></td>
<td align="left"><p class="table">pastes the previously copied or cut rich text (including text formats like color etc.) into user window (dock window) name.
selectString( line, 1 )
cut()
pasteWindow( "chat" )</p></td>
</tr>
<tr>
<td align="left"><p class="table">raiseEvent( event_name, arg-1, &#8230; arg-n )</p></td>
<td align="left"><p class="table">Raises the event event_name. The event system will call the main function (the one that is called exactly like
the script name) of all such scripts that have registered event handlers. If an event is raised, but no event handler scripts have been registered with
the event system, the event is ignored and nothing happens. This is convenient as you can raise events in your triggers, timers, scripts etc. without
having to care if the actual event handling has been implemented yet - or more specifically how it is implemented. Your triggers raise an event to
tell the system that they have detected a certain condition to be true or that a certain event has happened. How - and if - the system is going
to respond to this event is up to the system and your trigger scripts don&#8217;t have to care about such details.
For small systems it will be more convienient to use regular function calls instead of events, however, the more complicated your system will get,
the more important events will become because they help reduce complexity very much.</p>
<p class="table">The corresponding event handlers that listen to the events raised with raiseEvent() need to use the script name as function name and take the correct
number of arguments. NOTE: If you raise an event with 5 arguments but your event handlers functions only take 2,10 or 0 arguments, the functions
will not be called. For exmaple: raiseEvent("fight") a correct event handler function would be: myScript( event_name ). In this example raiseEvent
uses minimal arguments, name the event name. There can only be one event handler function per script, but a script can still handle multiple events
as the first argument is always the event name. So you can call your own special handlers for individual events. The reason behind this is that you
should rather use many individual scripts instead of one huge script that has all your function code etc. Scripts can be organized very well in trees
and thus help reduce complexity on large systems.</p></td>
</tr>
<tr>
<td align="left"><p class="table">replace( with )</p></td>
<td align="left"><p class="table">replaces the selected text with "with". To delete text use replace("")</p></td>
</tr>
<tr>
<td align="left"><p class="table">replaceAll( what, with )</p></td>
<td align="left"><p class="table">replaces all occurrences of what in the current line with with</p></td>
</tr>
<tr>
<td align="left"><p class="table">int pos_begin_of_match_in_line = selectString( text, number_of_match ) or -1 on error</p></td>
<td align="left"><p class="table">Selects a substring from the line where the user cursor is currently
positioned. You can move the user cursor with moveCursor(). When a new line arrives from the MUD, the user cursor is positioned at the beginning of
the line. However, if one of your trigger scripts moves the cursor around you need to take care of the cursor position yourself and make sure that
the cursor is in the correct line if you want to call one of the select functions.
NOTE: to prevent selection of random data use the error return if not found like this: "if selectString( "big monster", 1 ) &gt; -1 then setFgColor( 255,0,0) end"</p></td>
</tr>
<tr>
<td align="left"><p class="table">boolean = selectSection( from, length_of_string )</p></td>
<td align="left"><p class="table">Absolute column number for start of selection and length of selection</p></td>
</tr>
<tr>
<td align="left"><p class="table">selectCaptureGroup( groupNumber ) with first group = 0</p></td>
<td align="left"><p class="table">Selects the content of the capture group number in your perl regular expression e.g. "you have (\d+) Euro". If you want to color the amount of money you have green you do: selectCaptureGroup(1); setFgColor(0,255,0)</p></td>
</tr>
<tr>
<td align="left"><p class="table">send( command )</p></td>
<td align="left"><p class="table">This sends data directly to the socket layer, bypassing the alias expansion unit. If you want your command to be expanded by the alias unit, call expandAlias() instead.</p></td>
</tr>
<tr>
<td align="left"><p class="table">setBgColor( r,g,b )</p></td>
<td align="left"><p class="table">Values are RGB: red, green, blue ranging from 0-255 e.g. for red: setFgColor(255,0,0)</p></td>
</tr>
<tr>
<td align="left"><p class="table">setFgColor( r, g, b )</p></td>
<td align="left"><p class="table">Values are RGB: red, green, blue ranging from 0-255 e.g. for blue: setBgColor(0,0,255)</p></td>
</tr>
<tr>
<td align="left"><p class="table">timer_id = tempTimer( seconds, lua_code )</p></td>
<td align="left"><p class="table">Creates a temporary single shot timer. You can use 2.3 seconds or 0.45 etc. After it has fired, the timer will be deactivated and killed.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempTrigger( string, lua_code )</p></td>
<td align="left"><p class="table">creates a temporary trigger using substring matching. Contrary to tempTimers, tempTriggers live throughout the entire session unless they are explicitely disabled or killed. Disabled tempTimers can be reenabled with enableTrigger(). This is much faster than killing the trigger and creating a new one.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempLineTrigger( from, howMany, LuaCode )</p></td>
<td align="left"><p class="table">Temporary trigger that will fire on n consecutive lines following the current line. This is useful
to parse output that is known to arrive in a certain line margin or to delete unwanted output from the MUD. Example: tempLineTrigger( 1, 3, <a id="send("shout Help")"></a> ) will fire 3 times starting with the line from the MUD.
tempLineTrigger( 20, 2, <a id="send("shout Help")"></a> )
will fire 20 lines after the current line and fire twice on 2 consecutive lines.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempRegexTrigger( regex, lua_code )</p></td>
<td align="left"><p class="table">temorary trigger using perl regex pattern matching</p></td>
</tr>
<tr>
<td align="left"><p class="table">userWindowLineWrap( window, boolean )</p></td>
<td align="left"><p class="table">turns line wrap mode on or off in user dock windows
userWindowLineWrap( "chat", true ) turns on line wrap for window "chat"</p></td>
</tr>
<tr>
<td align="left"><p class="table">printTable( table_name )</p></td>
<td align="left"><p class="table">Lua debug function that prints the content of a Lua table on the screen, split up in keys and values. Useful if you want to see what the capture groups contain i. e. the lua table "matches".
This function is defined in luaglobal.lua.</p></td>
</tr>
<tr>
<td align="left"><p class="table">showCaptureGroups()</p></td>
<td align="left"><p class="table">Lua debug function that highlights all capture groups in your trigger regex on the screen. This is very handy if you make complex regex and want to see what really matches in the text. example: make a trigger with the regex (\w) and call this function in the trigger script. All words in the text will be highlighted in random colors. This function is defined in luaglobal.lua</p></td>
</tr>
<tr>
<td align="left"><p class="table">fg( "red" )</p></td>
<td align="left"><p class="table">Sets the current foreground color to red. Check the luaglobal.lua file for the defined color names ( about 255) e.g. fg("green") will set the foreground color to green.</p></td>
</tr>
<tr>
<td align="left"><p class="table">bg( "blue" )</p></td>
<td align="left"><p class="table">same as fg( color_name ) just for the background color.</p></td>
</tr>
<tr>
<td align="left"><p class="table">table.load( file, table )</p></td>
<td align="left"><p class="table">restores a Lua table from a data file that has been saved with table.save()</p></td>
</tr>
<tr>
<td align="left"><p class="table">table.save( file, table )</p></td>
<td align="left"><p class="table">saves the given table into the given file</p></td>
</tr>
<tr>
<td align="left"><p class="table">showCaptureGroups()</p></td>
<td align="left"><p class="table">a debug function for building triggers: this function highlights all capture groups in random colors in the MUD output text online on the screen. You get more precise debug information on what captured what and when if you look at the debug console (&#8594;trigger editor&#8594;bug symbol)</p></td>
</tr>
<tr>
<td align="left"><p class="table">printTable( table )</p></td>
<td align="left"><p class="table">another debug function that prints the content of a Lua table on the screen split in key and value.</p></td>
</tr>
<tr>
<td align="left"><p class="table">sendAll( what )</p></td>
<td align="left"><p class="table">sends a list of commands to the MUD</p></td>
</tr>
<tr>
<td align="left"><p class="table">suffix( what )</p></td>
<td align="left"><p class="table">prints "what" at the end of the line when used in a trigger script</p></td>
</tr>
<tr>
<td align="left"><p class="table">prefix( what )</p></td>
<td align="left"><p class="table">prints "what" at the beginning of a line when used in a trigger script</p></td>
</tr>
<tr>
<td align="left"><p class="table">debug( arg1 &#8230; argn )</p></td>
<td align="left"><p class="table">prints out debug information to the user debug console</p></td>
</tr>
<tr>
<td align="left"><p class="table">function replaceWildcard(what, replacement)</p></td>
<td align="left"><p class="table">Replaces the given wildcard (as a number) with the given text.</p>
<p class="table">Example: replaceWildcard(1, "hello") on a trigger of <tt>^You wave (goodbye)\.$</tt></p></td>
</tr>
<tr>
<td align="left"><p class="table">resetFormat()</p></td>
<td align="left"><p class="table">resets the user character format to the default.</p></td>
</tr>
<tr>
<td align="left"><p class="table"></p></td>
<td align="left"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2009-04-14 01:11:27 CEST
</div>
</div>
</body>
</html>
