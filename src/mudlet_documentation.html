<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.4.1" />
<title>Mudlet Manual</title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
</style>
</head>
<body>
<div id="header">
<h1>Mudlet Manual</h1>
</div>
<h2 id="_table_of_content">Table of Content</h2>
<div class="sectionbody">
<div class="paragraph"><p><a href="#heading1">1. General Introduction to Modern MUD Clients.</a></p></div>
<div class="paragraph"><p><a href="#heading2">2. Mudlet&#8217;s Command Line</a></p></div>
<div class="paragraph"><p><a href="#heading3">3. The Trigger Engine</a></p></div>
<div class="paragraph"><p><a href="#heading4">4. The Timer Engine</a></p></div>
<div class="paragraph"><p><a href="#heading5">5. Key Bindings</a></p></div>
<div class="paragraph"><p><a href="#heading6">6. User defined Buttons and Menus</a></p></div>
<div class="paragraph"><p><a href="#heading7">7. Introduction to Scripting with Mudlet</a></p></div>
<div class="paragraph"><p><a href="#heading8">8. Scripting API and Reference</a></p></div>
</div>
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Welcome to <strong>Mudlet</strong>, a modern MUD client for GNU/Linux that offers all the tools to get the most out of your gaming experience.
Throughout this document we hope to familiarize you with the basic aspects of Mudlet, from the interface to its <em>very</em> powerful and feature rich scripting backend.
The main focus in the development of Mudlet has been efficiency and performance, but we also try to make it as easily accessible
as possible. However, keep in mind that this is a complex piece of software with a large set of tools that do require some understanding of the underlying principle.
To use Mudlet in any meaningful way, you have to take a closer look at the technical section in this manual. If you are not familiar with using modern MUD clients in general you should also take a look
at the general introduction to MUD clients section in this manual.
You are welcome to ask questions on the forum of our website. If you find a bug, please let us know.</p></div>
<h3 id="_quick_start">Quick Start</h3>
<div class="paragraph"><p>To connect to the MUD of your choice, click on <tt>Connections</tt> → <tt>Connection Profiles</tt>.</p></div>
<div class="ulist"><ul>
<li>
<p>
Create a new profile by clicking on <tt>Add New Profile</tt>.
</p>
</li>
<li>
<p>
Specify the <tt>host</tt> and the <tt>port</tt> of the MUD (This information is usually found on the MUD&#8217;s homepage).
</p>
</li>
<li>
<p>
Now just click <tt>Connect</tt> to play!
</p>
</li>
</ul></div>
</div>
<h2 id="heading1">1. General Introduction to Modern MUD Clients</h2>
<div class="sectionbody">
<h3 id="_1_1_mudlet_8217_s_automation_features">1.1 Mudlet&#8217;s automation features</h3>
<div class="paragraph"><p>Mudlet offers a vast array of standard features to automate or otherwise improve your gaming experience. These include, but are not limited to:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Aliases</strong> – user-defined text input, which is converted into a different, usually longer input before being sent to the MUD, e.g. <tt>gg</tt> → <tt>get gold from ground;put gold in 2.bag</tt>.
</p>
</li>
<li>
<p>
<strong>Keybindings</strong> – also known as hotkeys, allow executing certain user-defined commands by simultaneously pressing a specific combination of keys, e.g. <tt>CTRL+H</tt> → <tt>send say Hello Miyuki!</tt> to the MUD or <tt>plays La Marseillaise</tt>
</p>
</li>
<li>
<p>
<strong>Triggers</strong> – execute user-defined commands upon receiving specific out from the MUD, e.g. MUD sends <tt>You see Elyssa standing here.</tt> → send <tt>poke Elyssa</tt> to the MUD.
</p>
</li>
<li>
<p>
<strong>Timers</strong> – delay the execution of a command or execute it after a specified period of time, e.g. <tt>throw gauntlet to Eric</tt>-<tt>wait 3 seconds</tt>-<tt>exclaim Let us end this here!</tt>
</p>
</li>
<li>
<p>
<strong>Variables</strong> – allow the user to store text or numbers for easier use inside scripts.
</p>
</li>
<li>
<p>
<strong>Events</strong> – allow the user to make triggers for specific events like when Mudlet has connected to the MUD, or even user-defined events to use in complex system making.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Scripting allows the user to create automation utilities (triggers, aliases) with the Lua scripting language. The possibilities of what can be achieved by using this technique are, practically speaking, endless - ranging from teaching the client how to heal your character in combat for you to creating a fully automated robot (known as `bot`s) that will completely take over the control for your character (especially useful for completing repetitive, rudimentary tasks).</p></div>
<h3 id="_1_2_automation_and_mud_rules">1.2 Automation and MUD rules</h3>
<div class="paragraph"><p>Effectively speaking, it is possible to create an AI (Artificial Intelligence) that does everything you can do in a MUD. Even more so, the program will be able outperform you in almost every routine operation. The difficulty of creating such a program depends on the task it has to perform: gathering loot being very easy, walking through a dungeon and leveling you character being moderately easy and socially interacting with other real people being outrageously difficult (see <a href="http://alice.pandorabots.com/">A.L.I.C.E.</a>). In the end of the day, you&#8217;re teaching your client to process information and act the way you consider best suited.
Because scripting is so powerful, it can give you a competitive advantage that some people consider it unfair or even cheating. As of the moment of this writing (2 November 2008), this sort of automation can be best observed in commercial massively-multiplayer online role-playing games (MMORPG), known as gold-farming or power-leveling. The basic idea is creating a system that will raise your character to the maximum level and gather in-game currency in the process, both of which can be effectively exchanged for real-world currency. The spread of the above aspects can have much more far reaching consequences than just being unfair, such as inflation, loss of balance in terms of game-mechanics or, ultimately, a complete crash of in-game economy. For more information see the paper <a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1235602">"Simple Economics of Real-Money Trading in Online Games"</a> by Jun-Sok Huhh of the Seoul National University.
For these, and various other, reasons the administrators and owners of the corresponding virtual worlds can forbid the usage of automation tools. A failure to comply can result in suspension or deletion of the user&#8217;s character or account for future denial of service.
By including scripting support in Mudlet, we effectively give you the ability to create and utilise AI tool-kits, however, we do not endorse or promote the usage of these systems if it&#8217;s prohibited in your MUD. Keep in mind that by cheating you can lessen the quality of gameplay for both, your fellow players and yourself.</p></div>
<h3 id="_1_3_basic_scripting">1.3 Basic scripting</h3>
<div class="paragraph"><p>The following part of the guide is written for new beginners in scripting. If you&#8217;re coming over from zMud or cMud, you may move on to section two.</p></div>
<h4 id="_1_4_variables_basics">1.4 Variables - basics</h4>
<div class="paragraph"><p>Variables are containers for data. In Lua, they can store numbers or words. You can use variables to store important information like how much gold do you have, or have them remember things for you.</p></div>
<div class="paragraph"><p>The syntax for making a variable remember a number is the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>variable = number</tt></pre>
</div></div>
<div class="paragraph"><p>Or to make it remember some text:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>variable = "some text"</tt></pre>
</div></div>
<div class="paragraph"><p>For example, here we&#8217;ll set the <tt>myhealth</tt> variable to number <tt>1345</tt>, and the <tt>myname</tt> variable to <tt>Anna</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>myhealth = 1345
myname = "Anna"</tt></pre>
</div></div>
<div class="paragraph"><p>You can also do basic maths easily, for example:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>a = 2 + 2 --sets variable a to the value of 4
b = a - 1 --sets variable b to the value of 3</tt></pre>
</div></div>
<div class="paragraph"><p>To concatenate strings together, you can use the <tt>..</tt> expression:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>first_name = "Joe"
last_name = "Plumber"
full_name = firstname .. " " .. last_name --sets the full_name variable to "Joe Plumber", with a space inbetween.</tt></pre>
</div></div>
<h4 id="_1_5_how_to_send_text_to_the_mud">1.5 How to send text to the mud</h4>
<div class="paragraph"><p>To send a command to the MUD, you can use the <tt>send()</tt> function. Data inside the quotes is sent to the MUD.</p></div>
<div class="paragraph"><p>For example, the following code sends the command to <tt>eat bread</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send("eat bread")</tt></pre>
</div></div>
<div class="paragraph"><p>If you&#8217;d like to include variables in the send command, you need to prefix and suffix them with two dots outside the quotes, like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>send("My name is " .. full_name .. ". What's yours?")</tt></pre>
</div></div>
<h4 id="_1_6_how_to_echo_text_to_yourself">1.6 How to echo text to yourself</h4>
<div class="paragraph"><p>To echo (show text to yourself) you can use the <tt>echo()</tt> or the <tt>insertText()</tt> function.
For example, the following code will display <tt>Time to eat dinner!</tt> on your screen:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>echo("Time to eat dinner")</tt></pre>
</div></div>
<div class="paragraph"><p>If you&#8217;d like to include variables in your echo, you concatenate the value of your variable to the text:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>my_old = 5;
echo("I have " .. my_gold .. " pieces of gold!");</tt></pre>
</div></div>
<h4 id="_1_7_aliases">1.7 Aliases</h4>
<div class="paragraph"><p>The aliases are the most basic way of automating the gameplay - you can use aliases to shorten the amount of typing you do. For example:</p></div>
<div class="quoteblock">
<div class="title">Example - Brew&#8217;o'Matic 6000</div>
<div class="content">
<div class="paragraph"><p>You&#8217;re walking around the epic dungeon of the Unholy Firedragon of Westersand, gathering roots in order to brew a potion and thus restore the growth of hair on Farmer Benedict&#8217;s bald head. Once you see a root, you need to:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>open the bag of tools
get the sickle of damnation from the bag of tools
cut the root of hair-growth
clean the sickle of damnation of deadly root acid
put the sickle of damnation in the bag of tools
close the bag of tools
open the magical bag of storing
take the root
put the root into the magical bag of storing
close the magical of storing</tt></pre>
</div></div>
<div class="paragraph"><p>and once you&#8217;re done, do the exact same thing nine more times&#8230; trice a day.</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Alternatively, you just create an alias that would do this all with a single command - for example, <tt>quest</tt>.</p></div>
<h5 id="_1_8_making_a_simple_alias">1.8 Making a simple alias</h5>
<div class="paragraph"><p>To get started, go click on the <tt>Aliases</tt> button in Mudlet, and then on the <tt>Add</tt> one. This will make a blank alias for you, which we&#8217;ll now fill in.</p></div>
<div class="paragraph"><p>The <tt>Alias name</tt> field is optional - it&#8217;s mainly used for the alias listing that you see on the left as an easy way to distintuish all of the aliases.
You can just name our alias <tt>test</tt> for now.
The <tt>Regex</tt> field is where you&#8217;d put in the alias command, i. e. the command that is being sent to the MUD instead of the alias. In other words, the alias is a front for a real command. We call this substitution process alias expansion.
Mudlet uses Perl regular expression aliases. Regexes are a special way of matching patterns of words. For the beginners it is enough to think of them as a general way to specify the words itself and their placement within the line.
For basic alias it is enough to know that the character ^ symbolizes the beginning of the line and the charachter $ symbolizes the end of the line.
If you want to make an alias "tw" that sends the command "take weapon", you don&#8217;t have to care about placement or pattern matching in general.
All you need to do is fill "tw" in the field called "Regex" and type "take weapon" in the field called "substitution". Then you need to save the new alias by clicking on the "Save" icon in the top middle.
The symbol for unsaved items disappears and makes way for a little blue checkbox. If this box is checked the alias is active. If the blue box is empty, the alias is deactived and will not work unless you press the "activate" toggle padlock icon.
Now you are ready to go. Type "tw" in the command line and press the enter key. Mudlet will send "take weapon" to the MUD.
Alias as basically, a feature to save you a bit of typing - much like buttons which will be described in detail in section two of the manual.
To learn more about more complex aliases have a look at section 2 of the manual.</p></div>
<h4 id="_1_9_simple_triggers">1.9 Simple Triggers</h4>
<div class="paragraph"><p>Triggers are an automation feature offered in many modern MUD clients. They allow you quicker response to a parcticular situation or greater convenience since you need to do less manual work.
The way a trigger works is simple: You define some text that you want to trigger some action. When the trigger sees this text in the MUD output, it&#8217;ll run the commands you&#8217;ve told it to.
Example: Whenever you see a bunny you want to attack it. You type "bunny" in the field titled "Add to List" and then either press the enter key or click on the little + icon next to the input line to add this word to the list of texts this trigger fires on.
Now you type "kill bunny" in the field called command. Then click on the save icon to save the trigger and make sure the trigger is actually active (= blue checkbox icon is checked). When the trigger is active each time the word "bunny" will appear in the MUD output, your trigger will issue the command "kill bunny".
If you want to stop hunting bunnies, you can simply select the bunny trigger and then click on the padlock icon to deactivate the trigger.
The trigger will stop to fire until you re-enable it again via the padlock icon.</p></div>
<h5 id="_1_10_matching_one_unknown">1.10 Matching one unknown</h5>
<div class="paragraph"><p>You can also set up a trigger to gather the scimitars, gold or whatever the skeletons could carry around with them. Since we do not know what the loot is, we will need to set up a trigger to match the line and take whatever was dropped. Examples:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>The skeleton drops ring.
The skeleton drops gold.
The skeleton drops scimitar.</tt></pre>
</div></div>
<div class="paragraph"><p><tt>The skeleton drops_</tt> is the generic segment of the line, the loot itself varies. Thus, we need to tell the client to <tt>take_</tt> whatever the skeleton dropped. We do this by setting up a so-called <tt>regular expression</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: The skeleton drops (.*?)\.
Script: send("take " .. matches[2]);</tt></pre>
</div></div>
<div class="paragraph"><p>The expression <tt>(.*?)</tt> matches any characters that the client receives between <tt>The skeleton drops_</tt> (NB: notice the blank at the end) and the full-stop.
<tt>matches[2]</tt> simply transfers <em>the first matched text fitting the search criterea</em> into the output (matches[1] contains the entire matched text, matches[2] contains the first capture group. More on this in section two of the manual).</p></div>
<h5 id="_1_11_matching_multiple_unknowns">1.11 Matching multiple unknowns</h5>
<div class="paragraph"><p>Now, let&#8217;s try making a trigger that would gather the loot from anybody:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: (.*?) drops (.*?).
Script:
send("take " .. matches[3])</tt></pre>
</div></div>
<div class="paragraph"><p>In this case, any time somebody, or something, drops something else, or someone else, the client will pick it up. Note that we used <tt>matches[3]</tt> instead of <tt>matches[2]</tt> this time, in order to pick up the second match. If we used <tt>matches[2]</tt>, we&#8217;d end up picking up the skeleton&#8217;s corpse.</p></div>
<h5 id="_1_12_matching_known_variants">1.12 Matching known variants</h5>
<div class="paragraph"><p>If you&#8217;re playing a MUD in English, you&#8217;ll notice that these triggers probably won&#8217;t work due to English syntax. Compare:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>The skeleton drops apple.
The skeleton drops an apple.</tt></pre>
</div></div>
<div class="paragraph"><p>Chances are that you&#8217;ll see the later a little more often. If we used our old RegEx, the output would look something like this.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>INPUT: The skeleton drops an apple.
OUTPUT: take an apple</tt></pre>
</div></div>
<div class="paragraph"><p>Most MUDs can&#8217;t handle determiners, such as articles (i.e. <tt>a</tt>, <tt>an</tt>, <tt>the</tt>) or quantifiers (e.g. <tt>five</tt>, <tt>some</tt>, <tt>each</tt>), in user-input. To match this line we could either create multiple triggers matching every possible article or a regular expression filtering out these words:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: (.*?) drops (a|an|the|some|a couple of|a few|) (.*?).
Script:
send("take " .. matches[4])</tt></pre>
</div></div>
<div class="paragraph"><p>Once again, note that we&#8217;re using the third match (<tt>matches[4]</tt>) this time.
NOTE: Certain other languages, with a morphology richer than that of English, might require a somewhat different approach. If you&#8217;re stuck, and your MUD-adminitrators don&#8217;t prohibit the use of triggers, try asking on the corresponding world&#8217;s forums.</p></div>
<div class="paragraph"><p>For more information, see the chapter Regular Expressions.</p></div>
<h4 id="_1_13_explain_basic_regex_characters_w_d_and_and_how_to_use_them_properly">1.13 explain basic regex characters (^, $, (\w+), (\d+) and .*) and how to use them properly.</h4>
<h4 id="_retrieving_wildcards_from_triggers">Retrieving wildcards from triggers</h4>
<div class="paragraph"><p>Wildcards from triggers are stored in the <em>matches[]</em> table. The first wildcard goes into <em>matches[1]</em>, second into <em>matches[2]</em>, and so on, for however many wildcards do you have in your trigger.</p></div>
<div class="paragraph"><p>For example, you&#8217;d like to say outloud how much gold did you pick up from a slain monster. The message that you get when you pick up the gold is the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>You pick up 16 gold.</tt></pre>
</div></div>
<div class="paragraph"><p>A trigger that matches this pattern could be the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: You pick up (\d+) gold</tt></pre>
</div></div>
<div class="paragraph"><p>And in your code, the variables <tt>matches[2]</tt> will contain the amount of gold you picked up (in this case, <em>16</em>). So now to say outloud how much gold did you loot, you can do the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Script: echo("I got " .. matches[2] " gold!")</tt></pre>
</div></div>
<h5 id="_more_advanced_example">More advanced example</h5>
<div class="paragraph"><p>Here&#8217;s an example by Heiko, which makes you talk like Yoda:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Perl Style Regular Expression: say (\w+).*(\w*).*(.*)
Script:  command = "say "..matches[4].." "..matches[2].." "..matches[3]</tt></pre>
</div></div>
<div class="paragraph"><p>What it does here is save the <tt>first word</tt>, the <tt>second word</tt> and then the <tt>rest of the text</tt> into wildcards. It then says <tt>rest of the text</tt> first, then the <tt>first word</tt> and then the <tt>second word</tt>.</p></div>
<h4 id="_1_14_how_to_highlight_words">1.14 How to highlight words</h4>
<div class="paragraph"><p>To highlight something in Mudlet, you first use the <tt>selectString()</tt> function to select what you&#8217;d like to highlight, and then either the <tt>fg</tt> function to color the letters or <tt>bg</tt> to highlight the background of the letters. For example, the following code would highlight the word <tt>pond</tt> in a bluebackground and red letters:
The first parameter to selectString() is the text you want to select and the second parameter tells the function which occurence of the word in the current line you want to select i.e. the first, the second, the third etc.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>selectString( "pond", 1 )
fg( "red " )
bg( "blue" )</tt></pre>
</div></div>
<h4 id="_1_15_keybindings">1.15 Keybindings</h4>
<div class="paragraph"><p>Keybindings, or hotkeys, are in many respects very similar to aliases, however, instead of typing in what you want to be done, you simply hit a key (or combination of keys) and let the Mudlet do the work.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Example - You don&#8217;t drink tea, you sip it!</div>
<div class="paragraph"><p>You&#8217;re participating in an in-game tea sipping contest. The winner is the first person to sip an Earl Grey, should the quiz-master make a vague reference to a series of tubes, or a Ceylon Mint, if he begins talking about the specific theory of relativity. In order to give us a competitive advantage, we will define two keybindings:</p></div>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>HOTKEY: F1
EXPAND TO: sip earl grey

HOTKEY: F2
EXPAND TO: sip ceylon mint</tt></pre>
</div></div>
<div class="paragraph"><p>Now you just have to listen, or rather read, carefully and hit either F1 or F2 to claim that prize.</p></div>
<div class="paragraph"><p>Another practical use for keybindings would be creating a so-called "targeting system", which is especially useful for grinding down armies of pumpkin-men in MUDs without auto-attack. See the Variables chapter for further details.</p></div>
<h4 id="_1_16_timers">1.16 Timers</h4>
<div class="paragraph"><p>Timers, as the name suggests, can be used to execute a specific command at a certain time, after a certain time or once every so often.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Example - Don&#8217;t miss the training!</div>
<div class="paragraph"><p>Your character can train in his attributes once every three hours. You could either try tracking this manually or add a trigger starting timer after each training. Once the three hours have passed, your character will conveniently say to himself that it is time to do a couple of push-ups.
MUDLET RECOMMENDS: Alternatively, you could also create a timer that would suggest that -you- take a break and do some real-life push-ups each two hours of playtime. Think of the possibilities!</p></div>
</div></div>
</div>
<h2 id="_mudlet">Mudlet</h2>
<div class="sectionbody">
<h3 id="_2_exporting_and_importing_profiles_or_packages">2.? Exporting and Importing Profiles or Packages</h3>
<div class="paragraph"><p>Mudlet stores your profiles as XML files in your home directory under .config/mudlet/profiles/your_profile_name/current (note the leading dot).</p></div>
<div class="paragraph"><p>The file name consists of the date and time, the profile was written to disc.
You can export packages of a trigger branch, alias branch, function key, scripts etc. by clicking on a folder in the tree of the particular item in question and then click on the export icon. You&#8217;ll be asked to give a filename for your package. You can export arbitrarily complex structures by moving them into a folder. You cannot mix items at the moment. Importing packages is straight forward and fully automatic.
You can also import entire profiles as they are basically packages.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph" id="example1"><div class="title">Example: How to use multilinematches[n][m]</div><p>(this example can be tested on the MUD batmud.bat.org)</p></div>
<div class="paragraph"><p>In the case of a multiline trigger with these 2 Perl regex as conditions:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>^You have (\w+) (\w+) (\w+) (\w+)
^You are (\w+).*(\w+).*</tt></pre>
</div></div>
<div class="paragraph"><p>The command "score" generates the following output on batMUD:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>You have an almost non-existent ability for avoiding hits.
You are irreproachably kind.
You have not completed any quests.
You are refreshed, hungry, very young and brave.</tt></pre>
</div></div>
<div class="paragraph"><p>If you add this script to the trigger:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>showMultimatches();</tt></pre>
</div></div>
<div class="paragraph"><p>The script, i.e. the call to the function showMultimatches() generates this output:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt> -------------------------------------------------------
 The table multimatches[n][m] contains:
 -------------------------------------------------------
regex 1 captured: (multimatches[1][1-n])
          key=1 value=You are irreproachably kind.
          key=2 value=irreproachably
          key=3 value=d
regex 2 captured: (multimatches[2][1-n])
          key=1 value=You have not completed any quests
          key=2 value=not
          key=3 value=completed
          key=4 value=any
          key=5 value=quests
regex 3 captured: (multimatches[3][1-n])
          key=1 value=You are refreshed, hungry, very young and brave.
          key=2 value=refreshed
          key=3 value=e
 -------------------------------------------------------</tt></pre>
</div></div>
<div class="paragraph"><p>You can now see what the table multimatches[][] contains in this case. The</p></div>
</div></div>
<h3 id="_temporary_triggers">Temporary Triggers</h3>
<div class="paragraph"><p>Temporary triggers are lightweight triggers that are tailored for typical scripting needs. These are only available via Lua scripting. They are not stored in profiles, but stay in memory as long as the program runs or until they are deleted (killTimer()).</p></div>
<h3 id="_line_triggers_scripting_only">Line Triggers (scripting only)</h3>
<div class="paragraph"><p>Line triggers trigger on a specified line in the future - or a sequence of lines - irrespective of the content of the line. This type of triggers can be very handy in scripting if you know what is coming e.g. you want to parse a table from the MUD, maps etc.</p></div>
<h3 id="heading3">The Timer Engine</h3>
<div class="paragraph"><p>Mudlet supports 3 different sort of timers:</p></div>
<div class="paragraph"><p>Timers that fire repeatedly in a certain interval specified by the user.</p></div>
<div class="paragraph"><p>Offset Timers are child timers of a parent timer and fire a single shot after a specified timeout after their parent firied its respective timeout. This interval is an offset to the interval of its parent timer. Example: parent timer fires every 30 seconds and by doing so kicks off 3 offset timers with an offset of 5 seconds each. Consequently, the 3 children fire 5 seconds after each time the parent timer fired. Offset timers differ visually from regular timers and are represented with a + icon for offset. Offset timers can be turned on and off by the user just like any other timer.</p></div>
<div class="paragraph"><p>Temporary Timers that very useful for scripting. They behave like regular timers, but they are one shot only timers. Temporary timers can not be accessed from the GUI and are not saved in profiles.
=== Accessing the Mudlet buffer
missing</p></div>
</div>
<h2 id="heading4">Lua API</h2>
<div class="sectionbody">
<div class="paragraph"><p>Mudlet defines several global Lua variables that are accessible from anywhere.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="hsides"
cellspacing="0" cellpadding="4">
<caption class="title">Lua Variables</caption>
<col width="50%" />
<col width="50%" />
<thead valign="top">
<tr>
<th align="left">Variable Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td align="left"><p class="table">command</p></td>
<td align="left"><p class="table">This variable holds the current user command. This is typically used in alias scripts.</p></td>
</tr>
<tr>
<td align="left"><p class="table">line</p></td>
<td align="left"><p class="table">This variable holds the content of the current line as being processed by the trigger engine. The engine runs all triggers on each line as it arrives from the MUD.</p></td>
</tr>
<tr>
<td align="left"><p class="table">matches[n]</p></td>
<td align="left"><p class="table">This Lua table is being used by Mudlet in the context of triggers that use Perl regular expressions. matches[1] holds the entire match, matches[2] holds the first capture group, matches[n] holds the n-th capture group.</p>
<p class="table">If the trigger uses the Perl style /g switch to evaluate <strong>all</strong> possible matches of the given regex within the current line, matches[n+1] will hold the second entire match, matches[n+2] the first capture group of the second match and matches[n+m] the m-th capture group of the second match.</p></td>
</tr>
<tr>
<td align="left"><p class="table">multimatches[n][m]</p></td>
<td align="left"><p class="table">This table is being used by Mudlet in the context of multiline triggers that use Perl regular expression. It holds the table matches[n] as described above for each Perl regular expression based condition of the multiline trigger. multimatches[5][4] may hold the 4th capture group of the 5th regex in the multiline trigger. This way you can examine and process all relevant data within a single script. Have a look at this <a href="#example1">example</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="hsides"
cellspacing="0" cellpadding="4">
<caption class="title">Lua API</caption>
<col width="50%" />
<col width="50%" />
<thead valign="top">
<tr>
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td align="left"><p class="table">clearUserWindow( window_name )</p></td>
<td align="left"><p class="table">Clears the user window with the name given as argument.</p></td>
</tr>
<tr>
<td align="left"><p class="table">copy()</p></td>
<td align="left"><p class="table">Copies the current selection to the clipboard. This function operates on rich text, i. e. the selected text including all its format codes like colors, fonts etc.</p></td>
</tr>
<tr>
<td align="left"><p class="table">cut()</p></td>
<td align="left"><p class="table">Cuts the current selection and stores it in the clipboard. This text remains available in the clipboard until it gets overwritten by another cut or copy operation. This function works on rich text ( see copy() )</p></td>
</tr>
<tr>
<td align="left"><p class="table">deleteLine()</p></td>
<td align="left"><p class="table">deletes the current Line under the user cursor.</p></td>
</tr>
<tr>
<td align="left"><p class="table"><strong>deselect()</strong></p></td>
<td align="left"><p class="table">deselects the last selected text</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableTimer( name )</p></td>
<td align="left"><p class="table">Use timer name or the id returned by tempTimer() to identify the timer that you want to disable.</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableTrigger( name )</p></td>
<td align="left"><p class="table">Use trigger name or the id returned by tempTrigger() to identify the timer that you want to disable.</p></td>
</tr>
<tr>
<td align="left"><p class="table">disableKey( name )</p></td>
<td align="left"><p class="table">Uses trigger name as id or the id returned by tempTrigger()</p></td>
</tr>
<tr>
<td align="left"><p class="table">echo( text )</p></td>
<td align="left"><p class="table">prints text to the main window</p></td>
</tr>
<tr>
<td align="left"><p class="table">echoUserWindow( window_name, text )</p></td>
<td align="left"><p class="table">prints text to user dock window name</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableTimer( name )</p></td>
<td align="left"><p class="table">enables or activates a timer that was previously disabled. The parameter "name" expects the timer ID that was returned by tempTimer() on creation of the timer or the name of the timer in case of a GUI timer</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableTrigger( name )</p></td>
<td align="left"><p class="table">enables a Trigger. see enableTimer() for more details.</p></td>
</tr>
<tr>
<td align="left"><p class="table">enableKey( name )</p></td>
<td align="left"><p class="table">enable key or key group "name"</p></td>
</tr>
<tr>
<td align="left"><p class="table">expandAlias( command )</p></td>
<td align="left"><p class="table">like send(), but without bypassing alias expansion. This function may lead to infinite recursion if you are not careful. This function can be used to make recursive alias expansion.</p></td>
</tr>
<tr>
<td align="left"><p class="table">lineNumber = getLineNumber()</p></td>
<td align="left"><p class="table">to get the absolute line number of the current user cursor</p></td>
</tr>
<tr>
<td align="left"><p class="table">number = getColumnNumber()</p></td>
<td align="left"><p class="table">To get the absolute column number of the current user cursor</p></td>
</tr>
<tr>
<td align="left"><p class="table">number = getLineCount()</p></td>
<td align="left"><p class="table">To get the absolute amount of lines in the current console buffer</p></td>
</tr>
<tr>
<td align="left"><p class="table">lua_table[relative_linenumber, content] = getLines( from_line_number, to_line_number )</p></td>
<td align="left"><p class="table">Returns a section of the content of the screen text buffer. Absolute line numbers are used</p></td>
</tr>
<tr>
<td align="left"><p class="table">number_of_last_line = getLineCount()</p></td>
<td align="left"><p class="table">number of the last line in the buffer</p></td>
</tr>
<tr>
<td align="left"><p class="table">insertText( string )</p></td>
<td align="left"><p class="table">Insertion takes place at the current position of the user cursor or replaces the current selection. Use deselect() to unselect unwanted selections to prevent overwriting.</p></td>
</tr>
<tr>
<td align="left"><p class="table">killTimer( name )</p></td>
<td align="left"><p class="table">Deletes a tempTimer. Use the Timer ID returned by tempTimer() as name parameter.</p></td>
</tr>
<tr>
<td align="left"><p class="table">killTrigger( name )</p></td>
<td align="left"><p class="table">See killTimer()</p></td>
</tr>
<tr>
<td align="left"><p class="table">boolean = moveCursor( windowName, x, y )</p></td>
<td align="left"><p class="table">Moves the user cursor of the window windowName to the absolute point (x,y). This function returns false if such a move is impossible e.g. the coordinates don&#8217;t exist. To determine tha correct coordinates use getLineNumber(), getColumnNumber() and getLastLineNumber(). The trigger engine will always place the user cursor at the beginning of the current line before the script is run. Use "main" for the main window and the name you called your user window otherwise.</p></td>
</tr>
<tr>
<td align="left"><p class="table">moveCursorEnd( windowName )</p></td>
<td align="left"><p class="table">Moves the cursor to the end of the buffer. "main" is the name of the main window, otherwise use the name of your user window.</p></td>
</tr>
<tr>
<td align="left"><p class="table">openUserWindow( name )</p></td>
<td align="left"><p class="table">Opens a user dockable console window for user output e.g. statistics, chat etc. If a window of such a name already exists, nothing happens. You can move these windows, dock them, make them into notebook tabs or float them.</p></td>
</tr>
<tr>
<td align="left"><p class="table">paste()</p></td>
<td align="left"><p class="table">pastes the previously copied or cut text including all format codes like color, font etc. at the current user cursor position. The copy(), cut() and paste() functions can be used to copy formated text from the main window to a user window without losing colors e. g. for chat windows, map windows etc.</p></td>
</tr>
<tr>
<td align="left"><p class="table">pasteWindow( name )</p></td>
<td align="left"><p class="table">pastes the previously copied or cut rich text (including text formats like color etc.) into user window (dock window) name.
selectString( line, 1 )
cut()
pasteWindow( "chat" )</p></td>
</tr>
<tr>
<td align="left"><p class="table">raiseEvent( event_name, arg-1, &#8230; arg-n )</p></td>
<td align="left"><p class="table">Raises the event event_name. The event system will call the main function (the one that is called exactly like
the script name) of all such scripts that have registered event handlers. If an event is raised, but no event handler scripts have been registered with
the event system, the event is ignored and nothing happens. This is convenient as you can raise events in your triggers, timers, scripts etc. without
having to care if the actual event handling has been implemented yet - or more specifically how it is implemented. Your triggers raise an event to
tell the system that they have detected a certain condition to be true or that a certain event has happened. How - and if - the system is going
to respond to this event is up to the system and your trigger scripts don&#8217;t have to care about such details.
For small systems it will be more convienient to use regular function calls instead of events, however, the more complicated your system will get,
the more important events will become because they help reduce complexity very much.</p>
<p class="table">The corresponding event handlers that listen to the events raised with raiseEvent() need to use the script name as function name and take the correct
number of arguments. NOTE: If you raise an event with 5 arguments but your event handlers functions only take 2,10 or 0 arguments, the functions
will not be called. For exmaple: raiseEvent("fight") a correct event handler function would be: myScript( event_name ). In this example raiseEvent
uses minimal arguments, name the event name. There can only be one event handler function per script, but a script can still handle multiple events
as the first argument is always the event name. So you can call your own special handlers for individual events. The reason behind this is that you
should rather use many individual scripts instead of one huge script that has all your function code etc. Scripts can be organized very well in trees
and thus help reduce complexity on large systems.</p></td>
</tr>
<tr>
<td align="left"><p class="table">replace( with )</p></td>
<td align="left"><p class="table">replaces the selected text with "with". To delete text use replace("")</p></td>
</tr>
<tr>
<td align="left"><p class="table">replaceAll( what, with )</p></td>
<td align="left"><p class="table">replaces all occurrences of what in the current line with with</p></td>
</tr>
<tr>
<td align="left"><p class="table">int pos_begin_of_match_in_line = selectString( text, number_of_match ) or -1 on error</p></td>
<td align="left"><p class="table">Selects a substring from the line where the user cursor is currently
positioned. You can move the user cursor with moveCursor(). When a new line arrives from the MUD, the user cursor is positioned at the beginning of
the line. However, if one of your trigger scripts moves the cursor around you need to take care of the cursor position yourself and make sure that
the cursor is in the correct line if you want to call one of the select functions.
NOTE: to prevent selection of random data use the error return if not found like this: "if selectString( "big monster", 1 ) &gt; -1 then setFgColor( 255,0,0) end"</p></td>
</tr>
<tr>
<td align="left"><p class="table">boolean = selectSection( from, length_of_string )</p></td>
<td align="left"><p class="table">Absolute column number for start of selection and length of selection</p></td>
</tr>
<tr>
<td align="left"><p class="table">selectCaptureGroup( groupNumber ) with first group = 0</p></td>
<td align="left"><p class="table">Selects the content of the capture group number in your perl regular expression e.g. "you have (\d+) Euro". If you want to color the amount of money you have green you do: selectCaptureGroup(1); setFgColor(0,255,0)</p></td>
</tr>
<tr>
<td align="left"><p class="table">send( command )</p></td>
<td align="left"><p class="table">This sends data directly to the socket layer, bypassing the alias expansion unit. If you want your command to be expanded by the alias unit, call expandAlias() instead.</p></td>
</tr>
<tr>
<td align="left"><p class="table">setBgColor( r,g,b )</p></td>
<td align="left"><p class="table">Values are RGB: red, green, blue ranging from 0-255 e.g. for red: setFgColor(255,0,0)</p></td>
</tr>
<tr>
<td align="left"><p class="table">setFgColor( r, g, b )</p></td>
<td align="left"><p class="table">Values are RGB: red, green, blue ranging from 0-255 e.g. for blue: setBgColor(0,0,255)</p></td>
</tr>
<tr>
<td align="left"><p class="table">timer_id = tempTimer( seconds, lua_code )</p></td>
<td align="left"><p class="table">Creates a temporary single shot timer. You can use 2.3 seconds or 0.45 etc. After it has fired, the timer will be deactivated and killed.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempTrigger( string, lua_code )</p></td>
<td align="left"><p class="table">creates a temporary trigger using substring matching. Contrary to tempTimers, tempTriggers live throughout the entire session unless they are explicitely disabled or killed. Disabled tempTimers can be reenabled with enableTrigger(). This is much faster than killing the trigger and creating a new one.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempLineTrigger( from, howMany, LuaCode )</p></td>
<td align="left"><p class="table">Temporary trigger that will fire on n consecutive lines following the current line. This is useful
to parse output that is known to arrive in a certain line margin or to delete unwanted output from the MUD. Example: tempLineTrigger( 1, 3, <a id="send("shout Help")"></a> ) will fire 3 times starting with the line from the MUD.
tempLineTrigger( 20, 2, <a id="send("shout Help")"></a> )
will fire 20 lines after the current line and fire twice on 2 consecutive lines.</p></td>
</tr>
<tr>
<td align="left"><p class="table">trigger_id = tempRegexTrigger( regex, lua_code )</p></td>
<td align="left"><p class="table">temorary trigger using perl regex pattern matching</p></td>
</tr>
<tr>
<td align="left"><p class="table">userWindowLineWrap( window, boolean )</p></td>
<td align="left"><p class="table">turns line wrap mode on or off in user dock windows
userWindowLineWrap( "chat", true ) turns on line wrap for window "chat"</p></td>
</tr>
<tr>
<td align="left"><p class="table">printTable( table_name )</p></td>
<td align="left"><p class="table">Lua debug function that prints the content of a Lua table on the screen, split up in keys and values. Useful if you want to see what the capture groups contain i. e. the lua table "matches".
This function is defined in luaglobal.lua.</p></td>
</tr>
<tr>
<td align="left"><p class="table">showCaptureGroups()</p></td>
<td align="left"><p class="table">Lua debug function that highlights all capture groups in your trigger regex on the screen. This is very handy if you make complex regex and want to see what really matches in the text. example: make a trigger with the regex (\w) and call this function in the trigger script. All words in the text will be highlighted in random colors. This function is defined in luaglobal.lua</p></td>
</tr>
<tr>
<td align="left"><p class="table">fg( "red" )</p></td>
<td align="left"><p class="table">Sets the current foreground color to red. Check the luaglobal.lua file for the defined color names ( about 255) e.g. fg("green") will set the foreground color to green.</p></td>
</tr>
<tr>
<td align="left"><p class="table">bg( "blue" )</p></td>
<td align="left"><p class="table">same as fg( color_name ) just for the background color.</p></td>
</tr>
<tr>
<td align="left"><p class="table">table.load( file, table )</p></td>
<td align="left"><p class="table">restores a Lua table from a data file that has been saved with table.save()</p></td>
</tr>
<tr>
<td align="left"><p class="table">table.save( file, table )</p></td>
<td align="left"><p class="table">saves the given table into the given file</p></td>
</tr>
<tr>
<td align="left"><p class="table">showCaptureGroups()</p></td>
<td align="left"><p class="table">a debug function for building triggers: this function highlights all capture groups in random colors in the MUD output text online on the screen. You get more precise debug information on what captured what and when if you look at the debug console (&#8594;trigger editor&#8594;bug symbol)</p></td>
</tr>
<tr>
<td align="left"><p class="table">printTable( table )</p></td>
<td align="left"><p class="table">another debug function that prints the content of a Lua table on the screen split in key and value.</p></td>
</tr>
<tr>
<td align="left"><p class="table">sendAll( what )</p></td>
<td align="left"><p class="table">sends a list of commands to the MUD</p></td>
</tr>
<tr>
<td align="left"><p class="table">suffix( what )</p></td>
<td align="left"><p class="table">prints "what" at the end of the line when used in a trigger script</p></td>
</tr>
<tr>
<td align="left"><p class="table">prefix( what )</p></td>
<td align="left"><p class="table">prints "what" at the beginning of a line when used in a trigger script</p></td>
</tr>
<tr>
<td align="left"><p class="table">debug( arg1 &#8230; argn )</p></td>
<td align="left"><p class="table">prints out debug information to the user debug console</p></td>
</tr>
<tr>
<td align="left"><p class="table">function replaceWildcard(what, replacement)</p></td>
<td align="left"><p class="table">Replaces the given wildcard (as a number) with the given text.</p>
<p class="table">Example: replaceWildcard(1, "hello") on a trigger of <tt>^You wave (goodbye)\.$</tt></p></td>
</tr>
<tr>
<td align="left"><p class="table"></p></td>
<td align="left"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2009-03-24 00:56:31 CEST
</div>
</div>
</body>
</html>
